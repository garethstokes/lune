module HealthAgent exposing (main)

{-| System health monitoring agent using Nova LLM analysis.

    Demonstrates:
    - Structured tool outputs with Nova.tool
    - JSON decoding of LLM responses
    - User approval workflows
    - RuntimeConfig guards for tool execution
-}

import Lune.IO as IO
import Lune.Task as Task
import Lune.String as Str
import Lune.Int as Int
import Lune.Float as Float
import Lune.List as List
import Lune.Json as RawJson exposing (Json)
import Lune.Json.Decode as D
import Lune.Json.Encode as E
import Nova exposing (newClient, provider, withModel, tool)
import Nova.Core as Core exposing (Error(..), Provider, Response)
import Nova.Tool as Tool
import Nova.Runtime as Runtime exposing (RuntimeConfig, ToolExecError(..))

-- Health check result types

type alias DiskUsage =
  { mountPoint : String
  , totalGb : Float
  , usedGb : Float
  , percentUsed : Int
  }

type alias MemoryUsage =
  { totalMb : Int
  , usedMb : Int
  , availableMb : Int
  , swapUsedMb : Int
  }

type alias ProcessInfo =
  { pid : Int
  , name : String
  , cpuPercent : Float
  , memoryPercent : Float
  }

type alias ServiceStatus =
  { name : String
  , isRunning : Bool
  , uptime : Maybe String
  }

type alias HealthReport =
  { disks : List DiskUsage
  , memory : MemoryUsage
  , topProcesses : List ProcessInfo
  , services : List ServiceStatus
  }

-- LLM analysis response types

type Severity =
  Critical
  | Warning
  | Info

type alias Issue =
  { severity : Severity
  , summary : String
  , details : String
  }

type alias ProposedAction =
  { id : Int
  , issue : String
  , action : String
  , command : String
  , risk : String
  , expectedOutcome : String
  }

type alias HealthAnalysis =
  { issues : List Issue
  , actions : List ProposedAction
  }

-- JSON encoders for health report

encodeDiskUsage : DiskUsage -> Json
encodeDiskUsage d =
  E.object
    [ { key = "mountPoint", value = E.string d.mountPoint }
    , { key = "totalGb", value = E.float d.totalGb }
    , { key = "usedGb", value = E.float d.usedGb }
    , { key = "percentUsed", value = E.int d.percentUsed }
    ]

encodeMemoryUsage : MemoryUsage -> Json
encodeMemoryUsage m =
  E.object
    [ { key = "totalMb", value = E.int m.totalMb }
    , { key = "usedMb", value = E.int m.usedMb }
    , { key = "availableMb", value = E.int m.availableMb }
    , { key = "swapUsedMb", value = E.int m.swapUsedMb }
    ]

encodeProcessInfo : ProcessInfo -> Json
encodeProcessInfo p =
  E.object
    [ { key = "pid", value = E.int p.pid }
    , { key = "name", value = E.string p.name }
    , { key = "cpuPercent", value = E.float p.cpuPercent }
    , { key = "memoryPercent", value = E.float p.memoryPercent }
    ]

encodeUptime : Maybe String -> Json
encodeUptime maybeUptime =
  case maybeUptime of
    Nothing -> E.null
    Just u -> E.string u

encodeServiceStatus : ServiceStatus -> Json
encodeServiceStatus s =
  E.object
    [ { key = "name", value = E.string s.name }
    , { key = "isRunning", value = E.bool s.isRunning }
    , { key = "uptime", value = encodeUptime s.uptime }
    ]

encodeHealthReport : HealthReport -> Json
encodeHealthReport r =
  E.object
    [ { key = "disks", value = E.list encodeDiskUsage r.disks }
    , { key = "memory", value = encodeMemoryUsage r.memory }
    , { key = "topProcesses", value = E.list encodeProcessInfo r.topProcesses }
    , { key = "services", value = E.list encodeServiceStatus r.services }
    ]

-- JSON decoders for LLM response

decodeSeverity : D.Decoder Severity
decodeSeverity =
  D.andThen
    (\s ->
      case s of
        "critical" -> D.succeed Critical
        "warning" -> D.succeed Warning
        "info" -> D.succeed Info
        _ -> D.fail (Str.append "Unknown severity: " s)
    )
    D.string

decodeIssue : D.Decoder Issue
decodeIssue =
  D.map3
    (\sev sum det -> { severity = sev, summary = sum, details = det })
    (D.field "severity" decodeSeverity)
    (D.field "summary" D.string)
    (D.field "details" D.string)

decodeProposedAction : D.Decoder ProposedAction
decodeProposedAction =
  D.andThen
    (\exp ->
      D.map5
        (\id iss act cmd risk ->
          { id = id
          , issue = iss
          , action = act
          , command = cmd
          , risk = risk
          , expectedOutcome = exp
          })
        (D.field "id" D.int)
        (D.field "issue" D.string)
        (D.field "action" D.string)
        (D.field "command" D.string)
        (D.field "risk" D.string)
    )
    (D.field "expectedOutcome" D.string)

decodeHealthAnalysis : D.Decoder HealthAnalysis
decodeHealthAnalysis =
  D.map2
    (\iss acts -> { issues = iss, actions = acts })
    (D.field "issues" (D.list decodeIssue))
    (D.field "actions" (D.list decodeProposedAction))

main : Task Unit Unit
main =
  IO.println "Health Agent placeholder"
