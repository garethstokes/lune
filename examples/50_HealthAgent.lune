{-| HealthAgent - LLM-powered system health analyzer

An AI agent that collects Linux system health metrics (memory, CPU, processes)
and uses an LLM to analyze issues and propose remediation actions.

Architecture:
  1. Data Collection - Reads /proc filesystem for memory, CPU, and process stats
  2. LLM Analysis - Sends metrics to Nova (LLM client) for issue detection
  3. Human-in-the-Loop - Presents proposed actions for user approval
  4. Action Recording - Approved commands are written to approved-commands.sh

Key types:
  - HealthReport: Aggregated system metrics (disk, memory, processes, services)
  - HealthAnalysis: LLM output with issues and proposed actions
  - AgentError: Union of LLM, decode, and system errors

Uses @derive(Json) for automatic JSON serialization of all data types.
-}
module HealthAgent exposing (main)

import Lune.IO as IO
import Lune.Task as Task
import Lune.String as Str
import Lune.Char as Char
import Lune.Int as Int
import Lune.Float as Float
import Lune.List as List
import Lune.Maybe as Maybe
import Lune.Bool as Bool
import Lune.Json as RawJson exposing (Json)
import Lune.Json.Decode as D
import Lune.Json.Encode as E
import Template exposing (render)
import Nova exposing (newClient, provider, withModel, tool)
import Nova.Core as Core exposing (Error(..), Provider, Response)
import Nova.Tool as Tool
import Nova.Runtime as Runtime exposing (RuntimeConfig, ToolExecError(..))


-- Data Types ----------------------------------------------------------------

@derive(Json)
type alias DiskUsage =
  { mountPoint : String
  , totalGb : Float
  , usedGb : Float
  , percentUsed : Int
  }

@derive(Json)
type alias MemoryUsage =
  { totalMb : Int
  , usedMb : Int
  , availableMb : Int
  , swapUsedMb : Int
  }

@derive(Json)
type alias ProcessInfo =
  { pid : Int
  , name : String
  , cpuPercent : Float
  , memoryPercent : Float
  }

@derive(Json)
type alias ServiceStatus =
  { name : String
  , isRunning : Bool
  , uptime : Maybe String
  }

@derive(Json)
type alias HealthReport =
  { disks : List DiskUsage
  , memory : MemoryUsage
  , topProcesses : List ProcessInfo
  , services : List ServiceStatus
  }

@derive(Json)
type Severity =
  Critical
  | Warning
  | Info

@derive(Json)
type alias Issue =
  { severity : Severity
  , summary : String
  , details : String
  }

@derive(Json)
type alias ProposedAction =
  { id : Int
  , issue : String
  , action : String
  , command : String
  , risk : String
  , expectedOutcome : String
  }

@derive(Json)
type alias HealthAnalysis =
  { issues : List Issue
  , actions : List ProposedAction
  }

type AgentError =
  LlmError Error
  | DecodeError String
  | SystemError String


-- Data Collection -----------------------------------------------------------

procReadFile : String -> Task AgentError String
procReadFile path =
  IO.readFile path
    |> Task.mapError (\_ -> SystemError (Str.append "Failed to read " path))

diskCheck : Task AgentError (List DiskUsage)
diskCheck = Task.succeed []

memoryCheck : Task AgentError MemoryUsage
memoryCheck =
  do
    contents <- procReadFile "/proc/meminfo"
    case parseMeminfo contents of
      Err msg ->
        Task.fail (SystemError msg)
      Ok m ->
        Task.succeed m

processCheck : Task AgentError (List ProcessInfo)
processCheck =
  do
    meminfo <- procReadFile "/proc/meminfo"
    memTotalKb <-
      (|>)
        (Maybe.toResult
          "meminfo: missing MemTotal"
          (meminfoValueKb "MemTotal" meminfo))
        Task.fromResult
      |> Task.mapError SystemError

    name <- procReadFile "/proc/self/comm" |> Task.map Str.trim

    status <- procReadFile "/proc/self/status"
    let rssKb =
      lineFirstInt
        "VmRSS:"
        status
      |> Maybe.withDefault 0

    sample0 <- sampleSelfCpu
    _ <- IO.sleepMs 200
    sample1 <- sampleSelfCpu

    let cpuPercent = cpuPercentFromSamples sample0 sample1

    let memoryPercent = Float.percent rssKb memTotalKb

    Task.succeed
      [ { pid = sample0.pid
      , name = name
      , cpuPercent = cpuPercent
      , memoryPercent = memoryPercent
      }
      ]

serviceCheck : Task AgentError (List ServiceStatus)
serviceCheck = Task.succeed []

collectHealthReport : Task AgentError HealthReport
collectHealthReport =
  do
    disks <- diskCheck
    memory <- memoryCheck
    processes <- processCheck
    services <- serviceCheck
    Task.succeed
      { disks = disks
      , memory = memory
      , topProcesses = processes
      , services = services
      }

type alias CpuSample =
  { pid : Int
  , procJiffies : Int
  , totalJiffies : Int
  , cpuCount : Int
  }

sampleSelfCpu : Task AgentError CpuSample
sampleSelfCpu =
  do
    sys <- procReadFile "/proc/stat"
    self <- procReadFile "/proc/self/stat"

    totalJiffies <-
      case procTotalJiffies sys of
        Err msg ->
          Task.fail (SystemError msg)
        Ok n ->
          Task.succeed n

    pidAndJiffies <-
      case procPidAndJiffies self of
        Err msg ->
          Task.fail (SystemError msg)
        Ok r ->
          Task.succeed r

    case pidAndJiffies of
      (pid, procJiffies) ->
        Task.succeed
          { pid = pid
          , procJiffies = procJiffies
          , totalJiffies = totalJiffies
          , cpuCount = Int.max 1 (procCpuCount sys)
          }

cpuPercentFromSamples : CpuSample -> CpuSample -> Float
cpuPercentFromSamples a b =
  let
    dp = Int.max 0 (Int.sub b.procJiffies a.procJiffies)
    dt = Int.max 0 (Int.sub b.totalJiffies a.totalJiffies)
  in
    case Int.lte dt 0 of
      True ->
        0.0
      False ->
        let
          ratio = Float.div (Float.fromInt dp) (Float.fromInt dt)
        in
          Float.mul (Float.fromInt a.cpuCount) (Float.mul 100.0 ratio)

parseMeminfo : String -> Result String MemoryUsage
parseMeminfo contents =
  do
    totalKb <-
      meminfoValueKb
        "MemTotal"
        contents
      |> Maybe.toResult "meminfo: missing MemTotal"
    availableKb <-
      meminfoValueKb
        "MemAvailable"
        contents
      |> Maybe.toResult "meminfo: missing MemAvailable"
    swapTotalKb <-
      meminfoValueKb
        "SwapTotal"
        contents
      |> Maybe.toResult "meminfo: missing SwapTotal"
    swapFreeKb <-
      meminfoValueKb
        "SwapFree"
        contents
      |> Maybe.toResult "meminfo: missing SwapFree"
    let totalMb = Int.div totalKb 1024
    let availableMb = Int.div availableKb 1024
    let usedMb =
      Int.sub
        totalMb
        availableMb
      |> Int.max 0
    let swapUsedMb =
      Int.div
        (Int.sub swapTotalKb swapFreeKb)
        1024
      |> Int.max 0
    Ok
      { totalMb = totalMb
      , usedMb = usedMb
      , availableMb = availableMb
      , swapUsedMb = swapUsedMb
      }

meminfoValueKb : String -> String -> Maybe Int
meminfoValueKb key contents =
  let
    prefix = Str.append key ":"
  in
    lineFirstInt prefix contents

lineFirstInt : String -> String -> Maybe Int
lineFirstInt prefix contents =
  case List.findFirst (\line -> Str.startsWith prefix line) (Str.lines contents) of
    Nothing ->
      Nothing
    Just line ->
      extractFirstInt line

extractFirstInt : String -> Maybe Int
extractFirstInt s =
  let
    chars = Str.toChars s
    after = List.dropWhile (\c -> Bool.not (Char.isDigit c)) chars
  in
    case after of
      [] ->
        Nothing
      _ ->
        let
          digits = List.takeWhile Char.isDigit after
        in
          case Str.toInt (Str.fromChars digits) of
            Err _ ->
              Nothing
            Ok n ->
              Just n

procTotalJiffies : String -> Result String Int
procTotalJiffies sys =
  case Str.lines sys of
    [] ->
      Err "proc/stat: empty"
    Cons first _ ->
      case Str.words first of
        [] ->
          Err "proc/stat: malformed cpu line"
        Cons _ rest ->
          Str.sumInts rest

procCpuCount : String -> Int
procCpuCount sys = List.foldl countCpuCoreLine 0 (Str.lines sys)

countCpuCoreLine : Int -> String -> Int
countCpuCoreLine n line =
  case isCpuCoreLine line of
    True ->
      Int.add n 1
    False ->
      n

isCpuCoreLine : String -> Bool
isCpuCoreLine line =
  case Str.startsWith "cpu" line of
    False ->
      False
    True ->
      case Str.toChars (Str.drop 3 line) of
        Cons c _ ->
          Char.isDigit c
        _ ->
          False

procPidAndJiffies : String -> Result String (Int, Int)
procPidAndJiffies statLine =
  case Str.words statLine of
    [] ->
      Err "proc/self/stat: missing pid"
    Cons pidToken _ ->
      case Str.toInt pidToken of
        Err msg ->
          Err (Str.append "proc/self/stat: invalid pid: " msg)
        Ok pid ->
          case Str.indexOf ") " statLine of
            Nothing ->
              Err "proc/self/stat: missing ') ' delimiter"
            Just idx ->
              let
                rest = Str.drop (Int.add idx 2) statLine
                fields = Str.words rest
              in
                case (List.get 11 fields, List.get 12 fields) of
                  (Just ut, Just st) ->
                    case (Str.toInt ut, Str.toInt st) of
                      (Ok utime, Ok stime) ->
                        Ok (pid, Int.add utime stime)
                      _ ->
                        Err "proc/self/stat: invalid utime/stime"
                  _ ->
                    Err "proc/self/stat: missing utime/stime fields"


-- Display -------------------------------------------------------------------

showSeverity : Severity -> String
showSeverity sev =
  case sev of
    Critical ->
      "CRITICAL"
    Warning ->
      "WARNING"
    Info ->
      "INFO"

showIssue : Issue -> String
showIssue iss = render "  * [${showSeverity iss.severity}] ${iss.summary}"

showIssuesHeader : String
showIssuesHeader = "Issues found:"

showIssues : List Issue -> String
showIssues issues =
  case issues of
    [] ->
      "No issues found."
    _ ->
      Str.join "\n" (Cons showIssuesHeader (List.map showIssue issues))

showAction : Int -> Int -> ProposedAction -> String
showAction current total act =
  render
    ''
      +-------------------------------------------------+
      | Action ${Str.fromInt current} of ${Str.fromInt total} [${act.risk} risk]
      |
      | Issue: ${act.issue}
      |
      | Proposed: ${act.action}
      | Command:  ${act.command}
      | Expected: ${act.expectedOutcome}
      +-------------------------------------------------+
    ''


-- Mock LLM Provider ---------------------------------------------------------

mockHealthProvider : Provider
mockHealthProvider = provider "mock-health"

mockHealthCall :
    Core.ProviderConfig -> String -> String -> IO (Result Core.Error Response)
mockHealthCall _ _ _ =
  IO.pure
    <| Ok
      { text = mockHealthAnalysisJson
      , usage = Just
          { inputTokens = 100, outputTokens = 50, totalTokens = 150 }
      }

mockHealthAnalysis : HealthAnalysis
mockHealthAnalysis =
  { issues =
    [ { severity = Critical
    , summary = "Disk /var is 94% full"
    , details = "Only 1.2GB remaining on /var partition"
    }
    , { severity = Warning
    , summary = "High memory usage"
    , details = "Process 'node' using 78% of available memory"
    }
    , { severity = Warning
    , summary = "Service redis is down"
    , details = "Redis service is not running"
    }
    ]
  , actions =
    [ { id = 1
    , issue = "Disk /var is 94% full"
    , action = "Clear journal logs older than 7 days"
    , command = "journalctl --vacuum-time=7d"
    , risk = "low"
    , expectedOutcome = "Free approximately 1-2GB"
    }
    , { id = 2
    , issue = "Service redis is down"
    , action = "Restart redis service"
    , command = "systemctl restart redis"
    , risk = "medium"
    , expectedOutcome = "Redis service will be available"
    }
    ]
  }

mockHealthAnalysisJson : String
mockHealthAnalysisJson =
  RawJson.stringify (healthAnalysisEncoder mockHealthAnalysis)

mockHealthProviderImpl : Core.ProviderImpl
mockHealthProviderImpl =
  { id = mockHealthProvider
  , call = mockHealthCall
  , capabilities = Core.setEmpty
  }

analysisSystemPrompt : String
analysisSystemPrompt =
  render
    ''
      You are a Linux sysadmin assistant. Analyze these system
      health metrics and identify issues that need attention.

      Severity guidelines:
      - Critical: System at risk of failure (disk >90%, OOM imminent)
      - Warning: Degraded performance or trending toward critical
      - Info: Notable but not actionable

      For each issue, propose a concrete remediation action with
      the exact command to run. Assess risk level:
      - low: Safe, no service impact (clear caches, rotate logs)
      - medium: Brief impact (restart service, kill process)
      - high: Potential data loss or extended downtime

      Return actions in priority order (most urgent first).
    ''

buildAnalysisPrompt : HealthReport -> String
buildAnalysisPrompt report =
  render
    ''
      ${analysisSystemPrompt}

      Health Report:
      ${RawJson.stringify (healthReportEncoder report)}
    ''

mockProviderRegistry : Core.ProviderRegistry
mockProviderRegistry =
  Core.dictInsert
    Nova.providerEq
    mockHealthProvider
    mockHealthProviderImpl
    Core.defaultProviderRegistry

makeClient : Nova.Client
makeClient = newClient mockProviderRegistry mockHealthProvider "health-analyzer"


-- Agent ---------------------------------------------------------------------

analyzeHealth : HealthReport -> Task AgentError HealthAnalysis
analyzeHealth report =
  do
    let prompt = buildAnalysisPrompt report
    analysisJson <-
      tool
        makeClient
        prompt
      |> Task.mapError LlmError
    D.decodeValue healthAnalysisDecoder analysisJson
      |> Task.fromResult
      |> Task.mapError (\d -> DecodeError d.message)

displayAnalysis : HealthAnalysis -> Task e Unit
displayAnalysis analysis =
  do
    IO.println ""
    IO.println (showIssues analysis.issues)
    IO.println ""
    case analysis.actions of
      [] ->
        IO.println "No remediation actions proposed."
      _ ->
        do
          let count = List.length analysis.actions
          IO.println
            (render "Proposed ${Str.fromInt count} remediation actions:")
          IO.println ""
          processActions count analysis.actions

showAgentError : AgentError -> String
showAgentError err =
  case err of
    LlmError e ->
      render "LLM analysis failed: ${Nova.showError e}"
    DecodeError msg ->
      render "Failed to decode response: ${msg}"
    SystemError msg ->
      render "System check failed: ${msg}"


-- Human-in-the-Loop ---------------------------------------------------------

type ApprovalResult =
  Approved
  | Skipped
  | Quit

promptForApproval : Task e ApprovalResult
promptForApproval =
  do
    IO.println
      "Approve this action (record command to approved-commands.sh)? [y/n/q] "
    input <- IO.readLine
    case input of
      "y" ->
        Task.succeed Approved
      "n" ->
        Task.succeed Skipped
      "q" ->
        Task.succeed Quit
      _ ->
        do
          IO.println "Please enter y, n, or q"
          promptForApproval

approvedCommandsPath : String
approvedCommandsPath = "approved-commands.sh"

recordApprovedCommand : String -> Task e String
recordApprovedCommand cmd =
  do
    existing <-
      Task.onError (IO.readFile approvedCommandsPath) (\_ -> Task.succeed "")
    let line = Str.append cmd "\n"
    let updated =
      case Str.isEmpty existing of
        True ->
          Str.append "#!/usr/bin/env sh\n\n" line
        False ->
          Str.append existing line
    _ <-
      Task.onError
        (IO.writeFile approvedCommandsPath updated)
        (\_ -> Task.succeed unit)
    Task.succeed (render "Recorded: ${cmd}")

processActions : Int -> List ProposedAction -> Task e Unit
processActions total actions = processActionsGo 1 total actions

processActionsGo : Int -> Int -> List ProposedAction -> Task e Unit
processActionsGo current total actions =
  case actions of
    [] ->
      do
        IO.println "All actions processed."
        Task.succeed unit
    Cons act rest ->
      do
        IO.println (showAction current total act)
        approval <- promptForApproval
        case approval of
          Quit ->
            do
              IO.println "Quitting. Remaining actions skipped."
              Task.succeed unit
          Skipped ->
            do
              IO.println "Action skipped."
              processActionsGo (Int.add current 1) total rest
          Approved ->
            do
              result <- recordApprovedCommand act.command
              IO.println result
              IO.println "Action recorded."
              processActionsGo (Int.add current 1) total rest


-- Main ----------------------------------------------------------------------

runAgent : Task AgentError Unit
runAgent =
  do
    IO.println "Collecting system health data..."
    report <- collectHealthReport

    IO.println <| render ''
          Health data collected.

          Analysing with LLM
        ''

    analysis <- analyzeHealth report
    displayAnalysis analysis

main : Task Unit Unit
main =
  do
    IO.println "=== Health Agent ==="
    IO.println ""
    result <- Task.result runAgent
    case result of
      Ok _ ->
        Task.succeed unit
      Err e ->
        IO.println (showAgentError e)
