{-| HealthAgent - LLM-powered system health analyzer

An AI agent that collects Linux system health metrics (memory, CPU, processes)
and uses an LLM to analyze issues and propose remediation actions.

Architecture:
  1. Data Collection - Uses Lune.System module for metrics
  2. LLM Analysis - Sends metrics to Ollama (qwen3 model) for issue detection
  3. Human-in-the-Loop - Presents proposed actions for user approval
  4. Action Recording - Approved commands are written to approved-commands.sh

Requirements:
  - Ollama running locally on port 11434
  - qwen3 model pulled: `ollama pull qwen3`

Key types:
  - HealthReport: Aggregated system metrics (memory, CPU, disk, network, GPU)
  - HealthAnalysis: LLM output with issues and proposed actions
  - AgentError: Union of LLM, decode, and system errors

Uses @derive(Json) for automatic JSON serialization of all data types.
-}
module HealthAgent exposing (main)

import Lune.IO as IO
import Lune.Task as Task
import Lune.String as Str
import Lune.Int as Int
import Lune.Float as Float
import Lune.List as List
import Lune.Json as RawJson exposing (Json)
import Lune.Json.Decode as D
import Lune.Json.Encode as E
import Lune.System as System exposing (Error(..), OS(..))
import Template exposing (render)
import Nova exposing (withModel, tool)
import Nova.Core as Core exposing (Error(..))


-- Data Types ----------------------------------------------------------------

@derive(Json)
type alias DiskUsage =
  { name : String
  , readBytesPerSec : Int
  , writeBytesPerSec : Int
  }

@derive(Json)
type alias MemoryUsage =
  { totalMb : Int
  , availableMb : Int
  , usedMb : Int
  , swapUsedMb : Int
  }

@derive(Json)
type alias CpuUsage =
  { usagePercent : Int
  , perCorePercent : List Int
  , loadAvg1 : Maybe Float
  , loadAvg5 : Maybe Float
  , loadAvg15 : Maybe Float
  }

@derive(Json)
type alias NetworkUsage =
  { rxBytesPerSec : Int
  , txBytesPerSec : Int
  , interfaces : List { name : String, rxBytesPerSec : Int, txBytesPerSec : Int }
  }

@derive(Json)
type alias GpuUsage =
  { busyPercent : Maybe Int
  , tempC : Maybe Float
  , powerW : Maybe Float
  , vramUsedBytes : Maybe Int
  }

@derive(Json)
type alias ProcessUsage =
  { pid : Int
  , name : String
  , cpuTimeDelta : Int
  , rssBytes : Maybe Int
  }

@derive(Json)
type alias HealthReport =
  { cpu : CpuUsage
  , memory : MemoryUsage
  , disks : List DiskUsage
  , network : NetworkUsage
  , gpus : List GpuUsage
  , topProcesses : List ProcessUsage
  , dtMs : Int
  }

@derive(Json)
type Severity =
  Critical
  | Warning
  | Info

@derive(Json)
type alias Issue =
  { severity : Severity
  , summary : String
  , details : String
  }

@derive(Json)
type alias ProposedAction =
  { id : Int
  , issue : String
  , action : String
  , command : String
  , risk : String
  , expectedOutcome : String
  }

@derive(Json)
type alias HealthAnalysis =
  { issues : List Issue
  , actions : List ProposedAction
  }

type AgentError =
  LlmError Core.Error
  | DecodeError String
  | SystemError System.Error


-- Data Collection -----------------------------------------------------------

collectHealthReport : Task AgentError HealthReport
collectHealthReport =
  do
    s1 <- System.sample |> Task.mapError SystemError
    _ <- IO.sleepMs 500
    s2 <- System.sample |> Task.mapError SystemError
    let d = System.diff s1 s2
    Task.succeed (diffToReport s2 d)

diffToReport : System.Sample -> System.Diff -> HealthReport
diffToReport s d =
  { cpu = cpuFromDiff d.cpu
  , memory = memFromSample s.mem
  , disks = disksFromDiff d.disk
  , network = netFromDiff d.net
  , gpus = gpusFromDiff d.gpu
  , topProcesses = procsFromDiff d.procs
  , dtMs = d.dtMs
  }

cpuFromDiff : System.CpuDiff -> CpuUsage
cpuFromDiff c =
  { usagePercent = c.usagePercent
  , perCorePercent = c.perCoreUsagePercent
  , loadAvg1 = c.loadAvg1
  , loadAvg5 = c.loadAvg5
  , loadAvg15 = c.loadAvg15
  }

memFromSample : System.MemMetrics -> MemoryUsage
memFromSample m =
  let
    totalMb = Int.div m.totalBytes (Int.mul 1024 1024)
    availableMb =
      case m.availableBytes of
        Just a ->
          Int.div a (Int.mul 1024 1024)
        Nothing ->
          case m.freeBytes of
            Just f ->
              Int.div f (Int.mul 1024 1024)
            Nothing ->
              0
    usedMb = Int.max 0 (Int.sub totalMb availableMb)
    swapUsedMb =
      case (m.swapTotalBytes, m.swapFreeBytes) of
        (Just total, Just free) ->
          Int.div (Int.max 0 (Int.sub total free)) (Int.mul 1024 1024)
        _ ->
          0
  in
    { totalMb = totalMb
    , availableMb = availableMb
    , usedMb = usedMb
    , swapUsedMb = swapUsedMb
    }

disksFromDiff : System.DiskDiff -> List DiskUsage
disksFromDiff d =
  List.map
    (\dev ->
      { name = dev.name
      , readBytesPerSec = dev.readBytesPerSec
      , writeBytesPerSec = dev.writeBytesPerSec
      })
    d.devices

netFromDiff : System.NetDiff -> NetworkUsage
netFromDiff n =
  { rxBytesPerSec = n.rxBytesPerSec
  , txBytesPerSec = n.txBytesPerSec
  , interfaces =
    List.map
      (\i ->
        { name = i.name
        , rxBytesPerSec = i.rxBytesPerSec
        , txBytesPerSec = i.txBytesPerSec
        })
      n.interfaces
  }

gpusFromDiff : System.GpuDiff -> List GpuUsage
gpusFromDiff g =
  List.map
    (\dev ->
      { busyPercent = dev.busyPercent
      , tempC = dev.tempC
      , powerW = dev.powerW
      , vramUsedBytes = dev.vramUsedBytes
      })
    g.devices

procsFromDiff : System.ProcessDiff -> List ProcessUsage
procsFromDiff p =
  List.map
    (\proc ->
      { pid = proc.pid
      , name = proc.comm
      , cpuTimeDelta = proc.cpuTimeDelta
      , rssBytes = proc.rssBytes
      })
    p.top


-- Display -------------------------------------------------------------------

showSeverity : Severity -> String
showSeverity sev =
  case sev of
    Critical ->
      "CRITICAL"
    Warning ->
      "WARNING"
    Info ->
      "INFO"

showIssue : Issue -> String
showIssue iss = render "  * [${showSeverity iss.severity}] ${iss.summary}"

showIssuesHeader : String
showIssuesHeader = "Issues found:"

showIssues : List Issue -> String
showIssues issues =
  case issues of
    [] ->
      "No issues found."
    _ ->
      Str.join "\n" (Cons showIssuesHeader (List.map showIssue issues))

showAction : Int -> Int -> ProposedAction -> String
showAction current total act =
  render
    ''
      +-------------------------------------------------+
      | Action ${Str.fromInt current} of ${Str.fromInt total} [${act.risk} risk]
      |
      | Issue: ${act.issue}
      |
      | Proposed: ${act.action}
      | Command:  ${act.command}
      | Expected: ${act.expectedOutcome}
      +-------------------------------------------------+
    ''


-- LLM Configuration ---------------------------------------------------------

analysisSystemPrompt : String
analysisSystemPrompt =
  render
    ''
      You are a Linux sysadmin assistant. Analyze these system
      health metrics and identify issues that need attention.

      Severity guidelines:
      - Critical: System at risk of failure (disk >90%, OOM imminent)
      - Warning: Degraded performance or trending toward critical
      - Info: Notable but not actionable

      For each issue, propose a concrete remediation action with
      the exact command to run. Assess risk level:
      - low: Safe, no service impact (clear caches, rotate logs)
      - medium: Brief impact (restart service, kill process)
      - high: Potential data loss or extended downtime

      Return actions in priority order (most urgent first).
    ''

buildAnalysisPrompt : HealthReport -> String
buildAnalysisPrompt report =
  render
    ''
      ${analysisSystemPrompt}

      Health Report:
      ${RawJson.stringify (healthReportEncoder report)}
    ''

makeClient : Nova.Client
makeClient =
  Nova.defaultClient
    |> withModel "qwen3"


-- Agent ---------------------------------------------------------------------

analyzeHealth : HealthReport -> Task AgentError HealthAnalysis
analyzeHealth report =
  do
    let prompt = buildAnalysisPrompt report
    analysisJson <-
      tool
        makeClient
        prompt
      |> Task.mapError LlmError
    D.decodeValue healthAnalysisDecoder analysisJson
      |> Task.fromResult
      |> Task.mapError (\d -> DecodeError d.message)

displayAnalysis : HealthAnalysis -> Task e Unit
displayAnalysis analysis =
  do
    IO.println ""
    IO.println (showIssues analysis.issues)
    IO.println ""
    case analysis.actions of
      [] ->
        IO.println "No remediation actions proposed."
      _ ->
        do
          let count = List.length analysis.actions
          IO.println
            (render "Proposed ${Str.fromInt count} remediation actions:")
          IO.println ""
          processActions count analysis.actions

showAgentError : AgentError -> String
showAgentError err =
  case err of
    LlmError e ->
      render "LLM analysis failed: ${Nova.showError e}"
    DecodeError msg ->
      render "Failed to decode response: ${msg}"
    SystemError e ->
      render "System check failed: ${systemErrorToString e}"

systemErrorToString : System.Error -> String
systemErrorToString err =
  case err of
    NotImplemented os ->
      Str.append "NotImplemented(" (Str.append (osToString os) ")")
    ReadError msg ->
      Str.append "ReadError(" (Str.append msg ")")
    ParseError msg ->
      Str.append "ParseError(" (Str.append msg ")")
    PermissionDenied msg ->
      Str.append "PermissionDenied(" (Str.append msg ")")

osToString : System.OS -> String
osToString os =
  case os of
    Linux ->
      "linux"
    Darwin ->
      "darwin"
    Windows ->
      "windows"


-- Human-in-the-Loop ---------------------------------------------------------

type ApprovalResult =
  Approved
  | Skipped
  | Quit

promptForApproval : Task e ApprovalResult
promptForApproval =
  do
    IO.println
      "Approve this action (record command to approved-commands.sh)? [y/n/q] "
    input <- IO.readLine
    case input of
      "y" ->
        Task.succeed Approved
      "n" ->
        Task.succeed Skipped
      "q" ->
        Task.succeed Quit
      _ ->
        do
          IO.println "Please enter y, n, or q"
          promptForApproval

approvedCommandsPath : String
approvedCommandsPath = "approved-commands.sh"

recordApprovedCommand : String -> Task e String
recordApprovedCommand cmd =
  do
    existing <-
      Task.onError (IO.readFile approvedCommandsPath) (\_ -> Task.succeed "")
    let line = Str.append cmd "\n"
    let updated =
      case Str.isEmpty existing of
        True ->
          Str.append "#!/usr/bin/env sh\n\n" line
        False ->
          Str.append existing line
    _ <-
      Task.onError
        (IO.writeFile approvedCommandsPath updated)
        (\_ -> Task.succeed unit)
    Task.succeed (render "Recorded: ${cmd}")

processActions : Int -> List ProposedAction -> Task e Unit
processActions total actions = processActionsGo 1 total actions

processActionsGo : Int -> Int -> List ProposedAction -> Task e Unit
processActionsGo current total actions =
  case actions of
    [] ->
      do
        IO.println "All actions processed."
        Task.succeed unit
    Cons act rest ->
      do
        IO.println (showAction current total act)
        approval <- promptForApproval
        case approval of
          Quit ->
            do
              IO.println "Quitting. Remaining actions skipped."
              Task.succeed unit
          Skipped ->
            do
              IO.println "Action skipped."
              processActionsGo (Int.add current 1) total rest
          Approved ->
            do
              result <- recordApprovedCommand act.command
              IO.println result
              IO.println "Action recorded."
              processActionsGo (Int.add current 1) total rest


-- Main ----------------------------------------------------------------------

runAgent : Task AgentError Unit
runAgent =
  do
    IO.println "Collecting system health data..."
    report <- collectHealthReport
    IO.println (render "Health data collected (sampled over ${Str.fromInt report.dtMs}ms).")
    IO.println ""
    IO.println "Analysing with LLM..."
    analysis <- analyzeHealth report
    displayAnalysis analysis

main : Task Unit Unit
main =
  do
    IO.println "=== Health Agent ==="
    IO.println ""
    result <- Task.result runAgent
    case result of
      Ok _ ->
        Task.succeed unit
      Err e ->
        IO.println (showAgentError e)
