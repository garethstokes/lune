module HealthAgent exposing (main)

{-| System health monitoring agent using Nova LLM analysis.

    Demonstrates:
    - Structured tool outputs with Nova.tool
    - JSON decoding of LLM responses
    - User approval workflows
    - RuntimeConfig guards for tool execution
-}

import Lune.IO as IO
import Lune.Task as Task
import Lune.String as Str
import Lune.Int as Int
import Lune.Float as Float
import Lune.List as List
import Lune.Json as RawJson exposing (Json)
import Lune.Json.Decode as D
import Lune.Json.Encode as E
import Template exposing (render)
import Nova exposing (newClient, provider, withModel, tool)
import Nova.Core as Core exposing (Error(..), Provider, Response)
import Nova.Tool as Tool
import Nova.Runtime as Runtime exposing (RuntimeConfig, ToolExecError(..))

-- Health check result types

type alias DiskUsage =
  { mountPoint : String
  , totalGb : Float
  , usedGb : Float
  , percentUsed : Int
  }

type alias MemoryUsage =
  { totalMb : Int
  , usedMb : Int
  , availableMb : Int
  , swapUsedMb : Int
  }

type alias ProcessInfo =
  { pid : Int
  , name : String
  , cpuPercent : Float
  , memoryPercent : Float
  }

type alias ServiceStatus =
  { name : String
  , isRunning : Bool
  , uptime : Maybe String
  }

type alias HealthReport =
  { disks : List DiskUsage
  , memory : MemoryUsage
  , topProcesses : List ProcessInfo
  , services : List ServiceStatus
  }

-- LLM analysis response types

type Severity =
  Critical
  | Warning
  | Info

type alias Issue =
  { severity : Severity
  , summary : String
  , details : String
  }

type alias ProposedAction =
  { id : Int
  , issue : String
  , action : String
  , command : String
  , risk : String
  , expectedOutcome : String
  }

type alias HealthAnalysis =
  { issues : List Issue
  , actions : List ProposedAction
  }

-- JSON encoders for health report

encodeDiskUsage : DiskUsage -> Json
encodeDiskUsage d =
  E.object
    [ { key = "mountPoint", value = E.string d.mountPoint }
    , { key = "totalGb", value = E.float d.totalGb }
    , { key = "usedGb", value = E.float d.usedGb }
    , { key = "percentUsed", value = E.int d.percentUsed }
    ]

encodeMemoryUsage : MemoryUsage -> Json
encodeMemoryUsage m =
  E.object
    [ { key = "totalMb", value = E.int m.totalMb }
    , { key = "usedMb", value = E.int m.usedMb }
    , { key = "availableMb", value = E.int m.availableMb }
    , { key = "swapUsedMb", value = E.int m.swapUsedMb }
    ]

encodeProcessInfo : ProcessInfo -> Json
encodeProcessInfo p =
  E.object
    [ { key = "pid", value = E.int p.pid }
    , { key = "name", value = E.string p.name }
    , { key = "cpuPercent", value = E.float p.cpuPercent }
    , { key = "memoryPercent", value = E.float p.memoryPercent }
    ]

encodeUptime : Maybe String -> Json
encodeUptime maybeUptime =
  case maybeUptime of
    Nothing -> E.null
    Just u -> E.string u

encodeServiceStatus : ServiceStatus -> Json
encodeServiceStatus s =
  E.object
    [ { key = "name", value = E.string s.name }
    , { key = "isRunning", value = E.bool s.isRunning }
    , { key = "uptime", value = encodeUptime s.uptime }
    ]

encodeHealthReport : HealthReport -> Json
encodeHealthReport r =
  E.object
    [ { key = "disks", value = E.list encodeDiskUsage r.disks }
    , { key = "memory", value = encodeMemoryUsage r.memory }
    , { key = "topProcesses", value = E.list encodeProcessInfo r.topProcesses }
    , { key = "services", value = E.list encodeServiceStatus r.services }
    ]

-- JSON decoders for LLM response

decodeSeverity : D.Decoder Severity
decodeSeverity =
  D.andThen
    (\s ->
      case s of
        "critical" -> D.succeed Critical
        "warning" -> D.succeed Warning
        "info" -> D.succeed Info
        _ -> D.fail (Str.append "Unknown severity: " s)
    )
    D.string

decodeIssue : D.Decoder Issue
decodeIssue =
  D.map3
    (\sev sum det -> { severity = sev, summary = sum, details = det })
    (D.field "severity" decodeSeverity)
    (D.field "summary" D.string)
    (D.field "details" D.string)

decodeProposedAction : D.Decoder ProposedAction
decodeProposedAction =
  D.andThen
    (\exp ->
      D.map5
        (\id iss act cmd risk ->
          { id = id
          , issue = iss
          , action = act
          , command = cmd
          , risk = risk
          , expectedOutcome = exp
          })
        (D.field "id" D.int)
        (D.field "issue" D.string)
        (D.field "action" D.string)
        (D.field "command" D.string)
        (D.field "risk" D.string)
    )
    (D.field "expectedOutcome" D.string)

decodeHealthAnalysis : D.Decoder HealthAnalysis
decodeHealthAnalysis =
  D.map2
    (\iss acts -> { issues = iss, actions = acts })
    (D.field "issues" (D.list decodeIssue))
    (D.field "actions" (D.list decodeProposedAction))

-- Mock health check functions (would use shell commands in production)

mockDiskCheck : Task e (List DiskUsage)
mockDiskCheck =
  Task.succeed
    [ { mountPoint = "/"
      , totalGb = 50.0
      , usedGb = 35.0
      , percentUsed = 70
      }
    , { mountPoint = "/var"
      , totalGb = 20.0
      , usedGb = 18.8
      , percentUsed = 94
      }
    ]

mockMemoryCheck : Task e MemoryUsage
mockMemoryCheck =
  Task.succeed
    { totalMb = 16384
    , usedMb = 12800
    , availableMb = 3584
    , swapUsedMb = 512
    }

mockProcessCheck : Task e (List ProcessInfo)
mockProcessCheck =
  Task.succeed
    [ { pid = 1234
      , name = "node"
      , cpuPercent = 45.2
      , memoryPercent = 78.0
      }
    , { pid = 5678
      , name = "postgres"
      , cpuPercent = 12.5
      , memoryPercent = 15.3
      }
    ]

mockServiceCheck : Task e (List ServiceStatus)
mockServiceCheck =
  Task.succeed
    [ { name = "nginx", isRunning = True, uptime = Just "3d 12h" }
    , { name = "redis", isRunning = False, uptime = Nothing }
    ]

collectHealthReport : Task e HealthReport
collectHealthReport =
  do
    disks <- mockDiskCheck
    memory <- mockMemoryCheck
    processes <- mockProcessCheck
    services <- mockServiceCheck
    Task.succeed
      { disks = disks
      , memory = memory
      , topProcesses = processes
      , services = services
      }

-- Display functions

showSeverity : Severity -> String
showSeverity sev =
  case sev of
    Critical -> "CRITICAL"
    Warning -> "WARNING"
    Info -> "INFO"

showIssue : Issue -> String
showIssue iss =
  Str.join ""
    [ "  * ["
    , showSeverity iss.severity
    , "] "
    , iss.summary
    ]

showIssues : List Issue -> String
showIssues issues =
  case issues of
    [] -> "No issues found."
    _ ->
      Str.join ""
        [ "Issues found:\n"
        , Str.join "\n" (List.map showIssue issues)
        ]

showAction : Int -> Int -> ProposedAction -> String
showAction current total act =
  Str.join ""
    [ "+-------------------------------------------------+\n"
    , "| Action "
    , Str.fromInt current
    , " of "
    , Str.fromInt total
    , " ["
    , act.risk
    , " risk]\n"
    , "|\n"
    , "| Issue: "
    , act.issue
    , "\n"
    , "|\n"
    , "| Proposed: "
    , act.action
    , "\n"
    , "| Command:  "
    , act.command
    , "\n"
    , "| Expected: "
    , act.expectedOutcome
    , "\n"
    , "+-------------------------------------------------+"
    ]

-- Mock LLM provider for deterministic testing

mockHealthProvider : Provider
mockHealthProvider = provider "mock-health"

mockHealthCall : Core.ProviderConfig -> String -> String -> IO (Result Core.Error Response)
mockHealthCall _ _ _ =
  IO.pure
    <| Ok
      { text = mockHealthAnalysisJson
      , usage = Just { inputTokens = 100, outputTokens = 50, totalTokens = 150 }
      }

mockHealthAnalysisJson : String
mockHealthAnalysisJson =
  render
    ''
    {
      "issues": [
        {
          "severity": "critical",
          "summary": "Disk /var is 94% full",
          "details": "Only 1.2GB remaining on /var partition"
        },
        {
          "severity": "warning",
          "summary": "High memory usage",
          "details": "Process 'node' using 78% of available memory"
        },
        {
          "severity": "warning",
          "summary": "Service redis is down",
          "details": "Redis service is not running"
        }
      ],
      "actions": [
        {
          "id": 1,
          "issue": "Disk /var is 94% full",
          "action": "Clear journal logs older than 7 days",
          "command": "journalctl --vacuum-time=7d",
          "risk": "low",
          "expectedOutcome": "Free approximately 1-2GB"
        },
        {
          "id": 2,
          "issue": "Service redis is down",
          "action": "Restart redis service",
          "command": "systemctl restart redis",
          "risk": "medium",
          "expectedOutcome": "Redis service will be available"
        }
      ]
    }
    ''

mockHealthProviderImpl : Core.ProviderImpl
mockHealthProviderImpl =
  { id = mockHealthProvider
  , call = mockHealthCall
  , capabilities = Core.setEmpty
  }

-- LLM analysis

analysisSystemPrompt : String
analysisSystemPrompt =
  render
    ''
    You are a Linux sysadmin assistant. Analyze these system
    health metrics and identify issues that need attention.

    Severity guidelines:
    - Critical: System at risk of failure (disk >90%, OOM imminent)
    - Warning: Degraded performance or trending toward critical
    - Info: Notable but not actionable

    For each issue, propose a concrete remediation action with
    the exact command to run. Assess risk level:
    - low: Safe, no service impact (clear caches, rotate logs)
    - medium: Brief impact (restart service, kill process)
    - high: Potential data loss or extended downtime

    Return actions in priority order (most urgent first).
    ''

buildAnalysisPrompt : HealthReport -> String
buildAnalysisPrompt report =
  Str.join ""
    [ analysisSystemPrompt
    , "\n\nHealth Report:\n"
    , RawJson.stringify (encodeHealthReport report)
    ]

main : Task Unit Unit
main =
  IO.println "Health Agent placeholder"
