module JsonOneOfEdgeCase exposing (main, testOneOfLastError)

{-| Regression test for oneOf edge case.

Verifies that:
  oneOf [ field "a" int, field "b" int ] applied to {}

yields:
  Err DecodeError with path == [Field "b"]

This ensures:
- left-to-right evaluation
- last error is returned on total failure

Run with: cabal run lune -- --eval examples/10_Json_OneOf_EdgeCase.lune
-}

import Lune.Prelude exposing (IO, Result(..), Unit, unit, List(..), Bool(..), String, Int)
import Lune.IO as IO
import Lune.String as Str
import Lune.Json as Json
import Lune.Json exposing (Json)
import Lune.Json.Decode as D
import Lune.Json.Decode exposing (PathItem(..))

main : IO Unit
main =
  do
    _ <- IO.println "=== oneOf Edge Case Test ==="
    _ <- testOneOfLastError
    pure unit

testOneOfLastError : IO Unit
testOneOfLastError =
  case Json.parse "{}" of
    Err _ -> IO.println "FAIL: Parse failed"
    Ok json -> checkOneOfResult json

checkOneOfResult : Json -> IO Unit
checkOneOfResult json =
  case D.decodeValue (D.oneOf (Cons (D.field "a" D.int) (Cons (D.field "b" D.int) Nil))) json of
    Ok _ -> IO.println "FAIL: Unexpected success"
    Err err ->
      case checkPath err.path of
        True -> IO.println (Str.append "PASS: Got expected error with path [Field \"b\"]: " err.message)
        False -> IO.println (Str.append "FAIL: Wrong path, expected [Field \"b\"], message: " err.message)

checkPath : List PathItem -> Bool
checkPath path =
  case path of
    Cons item Nil ->
      case item of
        Field name ->
          case Str.eq name "b" of
            True -> True
            False -> False
        Index _ -> False
    _ -> False
