module NovaDemo exposing (main)
import Lune.IO as IO
import Lune.Task as Task
import Lune.String as Str
import Lune.Json as RawJson
import Nova exposing (
  defaultClient
  , withOllamaBaseUrl
  , withProvider
  , withModel
  , openrouter
  , ollama
  , ask
  , json
  , tool
)
import Nova.Core exposing (Error(..))
-- | Convert a failable Task into a Task that always succeeds with a Result.

toResult : Task e a -> Task x (Result e a)
toResult task = Task.onError (Task.map Ok task) (\e -> Task.succeed (Err e))

showError : Error -> String
showError e =
  case e of
    NetworkError msg ->
      Str.append "NetworkError " msg
    RateLimited ->
      "RateLimited"
    Unauthorized ->
      "Unauthorized"
    BadRequest msg ->
      Str.append "BadRequest " msg
    ProviderError msg ->
      Str.append "ProviderError " msg
    DecodeError msg ->
      Str.append "DecodeError " msg

showAskResult : Result Error String -> String
showAskResult r =
  case r of
    Err e ->
      showError e
    Ok s ->
      s

showJsonResult : Result Error RawJson.Json -> String
showJsonResult r =
  case r of
    Err e ->
      showError e
    Ok j ->
      RawJson.stringify j

main : Task Unit Unit
main =
  do
    let baseClient = withOllamaBaseUrl "mock://" defaultClient
    IO.println "routing_openrouter_missing_key:"
    let openrouterClient =
      withProvider
        openrouter
        baseClient
      |> withModel "x"
    r1 <-
      ask
        openrouterClient
        "hi"
      |> toResult
    IO.println <| showAskResult r1
    IO.println "routing_ollama_mock:"
    let pureClient =
      withProvider
        ollama
        baseClient
      |> withModel "mock-pure"
    r2 <-
      ask
        pureClient
        "hi"
      |> toResult
    IO.println <| showAskResult r2
    IO.println "tool_wrapper_counts:"
    let toolWrapperClient =
      withProvider
        ollama
        baseClient
      |> withModel "mock-tool-wrapper"
    countsR <-
      tool
        toolWrapperClient
        "user"
      |> toResult
    IO.println <| showJsonResult countsR
    IO.println "json_pure:"
    jp <-
      json
        pureClient
        "p"
      |> toResult
    IO.println <| showJsonResult jp
    IO.println "tool_pure:"
    tp <-
      tool
        pureClient
        "p"
      |> toResult
    IO.println <| showJsonResult tp
    IO.println "json_prose_prefix:"
    let prosePrefixClient =
      withProvider
        ollama
        baseClient
      |> withModel "mock-prose-prefix"
    jpp <-
      json
        prosePrefixClient
        "p"
      |> toResult
    IO.println <| showJsonResult jpp
    IO.println "tool_prose_prefix:"
    tpp <-
      tool
        prosePrefixClient
        "p"
      |> toResult
    IO.println <| showJsonResult tpp
    IO.println "json_prose_suffix:"
    let proseSuffixClient =
      withProvider
        ollama
        baseClient
      |> withModel "mock-prose-suffix"
    jps <-
      json
        proseSuffixClient
        "p"
      |> toResult
    IO.println <| showJsonResult jps
    IO.println "tool_prose_suffix:"
    tps <-
      tool
        proseSuffixClient
        "p"
      |> toResult
    IO.println <| showJsonResult tps
    IO.println "tool_invalid:"
    let invalidClient =
      withProvider
        ollama
        baseClient
      |> withModel "mock-invalid"
    ti <-
      tool
        invalidClient
        "p"
      |> toResult
    IO.println <| showJsonResult ti
    IO.println "tool_no_json:"
    let noJsonClient =
      withProvider
        ollama
        baseClient
      |> withModel "mock-no-json"
    tn <-
      tool
        noJsonClient
        "p"
      |> toResult
    IO.println <| showJsonResult tn
