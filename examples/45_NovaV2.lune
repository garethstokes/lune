module NovaV2Demo exposing (main)
import Lune.IO as IO
import Lune.Task as Task
import Lune.String as Str
import Lune.Int as Int
import Lune.Json as RawJson exposing (Json)
import Lune.Json.Decode as Decode
import Lune.Json.Encode as Encode
import Nova exposing (
  newClient
  , provider
  , withHooks
  , withModel
  , ask
  , json
  , tool
  , askStream
  , next
  , StreamStep(..)
  , NovaEvent(..)
  , executeTool
)
import Nova.Core as Core exposing (
  Error(..)
  , Provider
  , ProviderConfig
  , Response
  , ProviderImpl
  , Capability(..)
  , Set
  , Usage
)
import Nova.Tool as Tool
import Nova.Runtime as Runtime exposing (RuntimeConfig, ToolExecError(..))

mockProvider : Provider
mockProvider = provider "mock"

mockCall _ model prompt =
  case model of
    "echo" ->
      IO.pure
        <| Ok
          { text = prompt
          , usage = Just
              { inputTokens = 0, outputTokens = 0, totalTokens = 0 }
          }
    "json" ->
      IO.pure
        <| Ok
          { text = "{\"n\":1}"
          , usage = Just
              { inputTokens = 0, outputTokens = 0, totalTokens = 0 }
          }
    "tool" ->
      IO.pure
        <| Ok
          { text = "ok\n{\"n\":2}\nbye"
          , usage = Just
              { inputTokens = 0, outputTokens = 0, totalTokens = 0 }
          }
    _ ->
      IO.pure (Err (ProviderError "Unknown model"))

mockProviderImpl =
  { id = mockProvider, call = mockCall, capabilities = Core.setEmpty }

hooks : Nova.NovaHooks
hooks =
  { onTurn = \_ -> IO.println "hook:onTurn"
  , onToolStart =
    \ctx ->
      Str.append "hook:onToolStart " (Tool.toolIdToString ctx.tool)
        |> IO.println
  , onToolFinish =
    \ctx ->
      Str.append "hook:onToolFinish " (Tool.toolIdToString ctx.tool)
        |> IO.println
  }

type alias AddArgs =
  { a : Int, b : Int }

addSpec : Tool.ToolSpec AddArgs
addSpec =
  { id = Tool.toolId "add" "1"
  , description = "Add two integers."
  , schema =
    Encode.object
      [ { key = "type", value = Encode.string "object" }
      , { key = "required", value = Encode.list Encode.string ["a", "b"] }
      ]
  , decoder =
    Tool.decodeJsonString
      (Decode.map2
        (\a b -> { a = a, b = b })
        (Decode.field "a" Decode.int)
        (Decode.field "b" Decode.int))
  }

runtimeAllow : RuntimeConfig
runtimeAllow =
  { maxTurns = 3
  , toolTimeoutMs = 250
  , allowedTools = Core.setFromList Tool.eqToolId [addSpec.id]
  , requireApproval = Core.setEmpty
  }

runtimeDeny : RuntimeConfig
runtimeDeny = { runtimeAllow | allowedTools = Core.setEmpty }

runAdd : AddArgs -> Task ToolExecError Int
runAdd args = Task.succeed (Int.add args.a args.b)

encodeAddArgs : AddArgs -> Json
encodeAddArgs args =
  Encode.object
    [ { key = "a", value = Encode.int args.a }
    , { key = "b", value = Encode.int args.b }
    ]

main : Task Unit Unit
main =
  do
    let providers =
      Core.dictInsert
        Nova.providerEq
        mockProvider
        mockProviderImpl
        Core.defaultProviderRegistry
    let client =
      newClient
        providers
        mockProvider
        "echo"
      |> withHooks hooks

    IO.println "ask:"
    a <- Task.fromIO (Task.attempt (ask client "Hello from Nova v2"))
    IO.println <| Nova.showAskResult a

    IO.println "json:"
    j <- Task.fromIO (Task.attempt (json (withModel "json" client) "ignored"))
    IO.println <| Nova.showJsonResult j

    IO.println "tool:"
    t <- Task.fromIO (Task.attempt (tool (withModel "tool" client) "ignored"))
    IO.println <| Nova.showJsonResult t

    IO.println "askStream:"
    let stream =
      askStream
        client
        "This is a longer string to demonstrate simulated streaming."
    s1 <- Task.fromIO <| next stream
    IO.println <| Nova.showStreamResult Nova.showError Nova.showEvent s1
    case s1 of
      Err _ ->
        Task.succeed unit
      Ok StreamEnd ->
        Task.succeed unit
      Ok StreamYield _ rest ->
        do
          s2 <- Task.fromIO <| next rest
          IO.println <| Nova.showStreamResult Nova.showError Nova.showEvent s2
          Task.succeed unit

    IO.println "executeTool_allow:"
    r1 <-
      executeTool
        client
        runtimeAllow
        addSpec
        encodeAddArgs
        Encode.int
        runAdd
        { a = 1, b = 2 }
      |> Task.result
    IO.println <| Nova.showToolExecResult r1

    IO.println "executeTool_deny:"
    r2 <-
      executeTool
        client
        runtimeDeny
        addSpec
        encodeAddArgs
        Encode.int
        runAdd
        { a = 1, b = 2 }
      |> Task.result
    IO.println <| Nova.showToolExecResult r2
