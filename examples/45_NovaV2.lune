module NovaV2Demo exposing (main)
import Lune.IO as IO
import Lune.Task as Task
import Lune.String as Str
import Lune.Int as Int
import Lune.Json as RawJson exposing (Json)
import Lune.Json.Decode as Decode
import Lune.Json.Encode as Encode
import Nova exposing (
  newClient
  , provider
  , withHooks
  , withModel
  , ask
  , json
  , tool
  , askStream
  , next
  , StreamStep(..)
  , NovaEvent(..)
  , executeTool
)
import Nova.Core as Core exposing (
  Error(..)
  , Provider
  , ProviderConfig
  , Response
  , ProviderImpl
  , Capability(..)
  , Set
  , Usage
)
import Nova.Tool as Tool
import Nova.Runtime as Runtime exposing (RuntimeConfig, ToolExecError(..))

mockProvider : Provider
mockProvider = provider "mock"

mockCall _ model prompt =
  case model of
    "echo" ->
      prim_ioPure <| Ok
          { text = prompt, usage = Just
              { inputTokens = 0, outputTokens = 0, totalTokens = 0 } }
    "json" ->
      prim_ioPure <| Ok
          { text = "{\"n\":1}", usage = Just
              { inputTokens = 0, outputTokens = 0, totalTokens = 0 } }
    "tool" ->
      prim_ioPure <| Ok
          { text = "ok\n{\"n\":2}\nbye", usage = Just
              { inputTokens = 0, outputTokens = 0, totalTokens = 0 } }
    _ ->
      prim_ioPure (Err (ProviderError "Unknown model"))

mockProviderImpl =
  { id = mockProvider, call = mockCall, capabilities = Core.setEmpty }

hooks : Nova.NovaHooks
hooks =
  { onTurn = \_ -> prim_putStrLn "hook:onTurn"
  , onToolStart =
    \ctx ->
      Str.append "hook:onToolStart " (Tool.toolIdToString ctx.tool)
        |> prim_putStrLn
  , onToolFinish =
    \ctx ->
      Str.append "hook:onToolFinish " (Tool.toolIdToString ctx.tool)
        |> prim_putStrLn
  }

type alias AddArgs =
  { a : Int, b : Int }

addSpec : Tool.ToolSpec AddArgs
addSpec =
  { id = Tool.toolId "add" "1"
  , description = "Add two integers."
  , schema =
    Encode.object
      [
        { key = "type", value = Encode.string "object" }
        , { key = "required", value = Encode.list Encode.string ["a", "b"] }
      ]
  , decoder =
    Tool.decodeJsonString
      (Decode.map2
        (\a b -> { a = a, b = b })
        (Decode.field "a" Decode.int)
        (Decode.field "b" Decode.int))
  }

runtimeAllow : RuntimeConfig
runtimeAllow =
  { maxTurns = 3
  , toolTimeoutMs = 250
  , allowedTools = Core.setFromList Tool.eqToolId [addSpec.id]
  , requireApproval = Core.setEmpty
  }

runtimeDeny : RuntimeConfig
runtimeDeny = { runtimeAllow | allowedTools = Core.setEmpty }

runAdd : AddArgs -> IO (Result ToolExecError Int)
runAdd args = prim_ioPure (Ok (Int.add args.a args.b))

encodeAddArgs : AddArgs -> Json
encodeAddArgs args =
  Encode.object
    [
      { key = "a", value = Encode.int args.a }
      , { key = "b", value = Encode.int args.b }
    ]

main : Task Unit Unit
main =
  do
    let providers = Core.dictInsert Nova.providerEq mockProvider mockProviderImpl Core.defaultProviderRegistry
    let client = withHooks hooks (newClient providers mockProvider "echo")
    IO.println "ask:"
    a <- Task.fromIO <| ask client "Hello from Nova v2"
    IO.println <| Nova.showAskResult a
    IO.println "json:"
    j <- Task.fromIO <| json (withModel "json" client) "ignored"
    IO.println <| Nova.showJsonResult j
    IO.println "tool:"
    t <- Task.fromIO <| tool (withModel "tool" client) "ignored"
    IO.println <| Nova.showJsonResult t
    IO.println "askStream:"
    let stream = askStream client "This is a longer string to demonstrate simulated streaming."
    s1 <- Task.fromIO <| next stream
    IO.println <| Nova.showStreamResult Nova.showError Nova.showEvent s1
    case s1 of
      Err _ ->
        Task.succeed unit
      Ok step ->
        case step of
          StreamEnd ->
            Task.succeed unit
          StreamYield _ rest ->
            do
              s2 <- Task.fromIO <| next rest
              IO.println <| Nova.showStreamResult Nova.showError Nova.showEvent s2
              Task.succeed unit
    IO.println "executeTool_allow:"
    x1 <- Task.fromIO <| executeTool client runtimeAllow addSpec encodeAddArgs Encode.int runAdd
          { a = 1, b = 2 }
    IO.println <| Nova.showToolExecResult x1
    IO.println "executeTool_deny:"
    x2 <- Task.fromIO <| executeTool client runtimeDeny addSpec encodeAddArgs Encode.int runAdd
          { a = 1, b = 2 }
    IO.println <| Nova.showToolExecResult x2
