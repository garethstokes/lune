module JsonDecode exposing (main)

{-| Demonstrates JSON decoding with Lune.Json.Decode -}

import Lune.IO as IO
import Lune.Json as Json
import Lune.Json.Decode as D
import Lune.Json.Decode exposing (Decoder)
import Lune.String as Str
import Lune.Prelude exposing (IO, Unit, Result(..), Maybe(..), String, Float)

main : IO Unit
main =
  do
    IO.println "=== JSON Decoding ==="
    decodeUser
    decodeNested
    decodeWithMaybe

decodeUser : IO Unit
decodeUser =
  case Json.parse "{\"name\":\"Bob\",\"score\":87.5}" of
    Err msg -> IO.println (Str.append "Parse error: " msg)
    Ok json ->
      case D.decodeValue userDecoder json of
        Err err -> IO.println (Str.append "Decode error: " err.message)
        Ok user -> IO.println (Str.append "User: " user.name)

userDecoder : Decoder { name : String, score : Float }
userDecoder =
  D.map2 (\n s -> { name = n, score = s })
    (D.field "name" D.string)
    (D.field "score" D.float)

decodeNested : IO Unit
decodeNested =
  case Json.parse "{\"data\":{\"value\":42.0}}" of
    Err _ -> IO.println "Parse failed"
    Ok json ->
      case D.decodeValue (D.at ["data", "value"] D.float) json of
        Err err -> IO.println (Str.append "Error: " err.message)
        Ok v -> IO.println (Str.append "Nested value: " (Str.fromFloat v))

decodeWithMaybe : IO Unit
decodeWithMaybe =
  case Json.parse "{\"required\":1,\"optional\":null}" of
    Err _ -> IO.println "Parse failed"
    Ok json ->
      case D.decodeValue (D.field "optional" (D.maybe D.int)) json of
        Err err -> IO.println (Str.append "Error: " err.message)
        Ok Nothing -> IO.println "Optional field is null"
        Ok (Just n) -> IO.println "Has value"
