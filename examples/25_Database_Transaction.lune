module DatabaseTransaction exposing (main)

{-| Database Transaction example.

This demonstrates Milestone 7 of the database module:
- Transaction begin/commit/rollback primitives
- Automatic transaction wrapper
- Rollback on error

Note: This example requires a PostgreSQL database to run.
Without a database, it will show a connection error (expected).
-}

import Lune.IO as IO
import Lune.Prelude exposing (IO, Result(..), Unit, List(..), Maybe(..), Int, String, Bool(..))
import Lune.Database as Database exposing (DbConn, DbError(..), DbValue(..))
import Lune.Database.Decode as Decode exposing (Decoder)
import Lune.Database.Query as Query exposing (Table, Column, Query, Order(..))
import Lune.Database.Postgres as Postgres
import Lune.String as Str

-- Define the users table
users : Table
users = Query.table "users"

users_id : Column Int
users_id = Query.column users "id"

users_name : Column String
users_name = Query.column users "name"

users_email : Column String
users_email = Query.column users "email"

-- User type and decoder
type alias User =
  { id : Int
  , name : String
  , email : String
  }

userDecoder : Decoder User
userDecoder =
  Decode.map3 (\id name email -> { id = id, name = name, email = email })
    (Decode.index 0 Decode.int)
    (Decode.index 1 Decode.string)
    (Decode.index 2 Decode.string)

-- Example: Create multiple users in a transaction (all or nothing)
createUsers : DbConn -> List { name : String, email : String } -> IO (Result DbError (List User))
createUsers conn newUsers =
  Postgres.transaction conn (\tx ->
    createUsersHelper tx newUsers Nil
  )

createUsersHelper : DbConn -> List { name : String, email : String } -> List User -> IO (Result DbError (List User))
createUsersHelper conn remaining created =
  case remaining of
    Nil -> pure (Ok created)
    Cons u rest ->
      do
        insertQuery <-
          pure (Query.returning
            (Query.values
              (Cons (Query.set users_name (Database.string u.name))
                (Cons (Query.set users_email (Database.string u.email)) Nil))
              (Query.insert users userDecoder)))
        result <- Postgres.run conn insertQuery
        case result of
          Err e -> pure (Err e)
          Ok inserted ->
            case inserted of
              Nil -> pure (Err (QueryFailed "Insert returned no rows"))
              Cons user _ -> createUsersHelper conn rest (Cons user created)

main : IO Unit
main =
  do
    IO.println "=== Transaction Examples ==="
    IO.println ""
    IO.println "This example demonstrates the transaction API."
    IO.println ""
    IO.println "1. Manual transaction control:"
    IO.println "   Postgres.begin conn"
    IO.println "   -- run queries --"
    IO.println "   Postgres.commit conn  -- or Postgres.rollback conn"
    IO.println ""
    IO.println "2. Automatic transaction wrapper:"
    IO.println "   Postgres.transaction conn (\\tx ->"
    IO.println "     do"
    IO.println "       result1 <- Postgres.run tx query1"
    IO.println "       result2 <- Postgres.run tx query2"
    IO.println "       pure (Ok result))"
    IO.println ""
    IO.println "   -- Commits on Ok, rolls back on Err"
    IO.println ""
    IO.println "3. Type signature:"
    IO.println "   transaction : DbConn -> (DbConn -> IO (Result DbError a)) -> IO (Result DbError a)"
    IO.println ""
    IO.println "4. Example: Create multiple users atomically"
    IO.println "   createUsers : DbConn -> List NewUser -> IO (Result DbError (List User))"
    IO.println "   createUsers conn newUsers ="
    IO.println "     Postgres.transaction conn (\\tx ->"
    IO.println "       -- insert each user, rollback if any fails"
    IO.println "       createUsersHelper tx newUsers Nil)"
    IO.println ""
    IO.println "Done!"
