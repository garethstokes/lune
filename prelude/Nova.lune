module Nova exposing (
  Provider(..),
  openrouter,
  ollama,
  Model,
  Usage,
  Response,
  Error(..),
  Request,
  Client,
  OpenRouterConfig,
  OllamaConfig,
  defaultClient,
  withOpenRouterKey,
  withOpenRouterBaseUrl,
  withOllamaBaseUrl,
  openrouterModel,
  ollamaModel,
  ask,
  json,
  tool,
  toolPreamble,
  toolPostamble
)

{-| Nova (v0): lightweight LLM client surface for Lune.

Template-first API:
- Prompts are `Template` (interpolation splices templates, not strings).
- `tool` enforces "JSON only" via prompt wrappers + best-effort JSON extraction.

Provider support (v0):
- OpenRouter: requires API key (returns Unauthorized if missing).
- Ollama: local models (HTTP client is stubbed; supports a mock mode for tests).
-}

import Lune.Prelude exposing (Bool(..), Int, String, List(..), Maybe(..), Result(..))
import Lune.Int as Int
import Lune.String as Str
import Template exposing (Template, Semigroup(..))
import Json
import Lune.Json as RawJson

--------------------------------------------------------------------------------
-- Models
--------------------------------------------------------------------------------

type Provider =
  OpenRouter
  | Ollama

-- Convenience values matching spec naming.
openrouter : Provider
openrouter =
  OpenRouter

ollama : Provider
ollama =
  Ollama

type alias Model =
  { provider : Provider
  , id : String
  }

--------------------------------------------------------------------------------
-- Usage + responses
--------------------------------------------------------------------------------

type alias Usage =
  { inputTokens : Int
  , outputTokens : Int
  , totalTokens : Int
  }

type alias Response =
  { text : String
  , usage : Maybe Usage
  }

--------------------------------------------------------------------------------
-- Errors
--------------------------------------------------------------------------------

type Error =
  NetworkError String
  | RateLimited
  | Unauthorized
  | BadRequest String
  | ProviderError String
  | DecodeError String

--------------------------------------------------------------------------------
-- Core request
--------------------------------------------------------------------------------

type alias Request =
  { model : Model
  , prompt : Template
  }

--------------------------------------------------------------------------------
-- Client config
--------------------------------------------------------------------------------

type alias Client =
  { openrouter : OpenRouterConfig
  , ollama : OllamaConfig
  }

type alias OpenRouterConfig =
  { baseUrl : String
  , apiKey : Maybe String
  , appName : Maybe String
  }

type alias OllamaConfig =
  { baseUrl : String
  }

defaultClient : Client
defaultClient =
  { openrouter =
      { baseUrl = "https://openrouter.ai/api/v1"
      , apiKey = Nothing
      , appName = Nothing
      }
  , ollama =
      { baseUrl = "http://localhost:11434"
      }
  }

withOpenRouterKey : String -> Client -> Client
withOpenRouterKey key client =
  { openrouter =
      { baseUrl = client.openrouter.baseUrl
      , apiKey = Just key
      , appName = client.openrouter.appName
      }
  , ollama = client.ollama
  }

withOpenRouterBaseUrl : String -> Client -> Client
withOpenRouterBaseUrl url client =
  { openrouter =
      { baseUrl = url
      , apiKey = client.openrouter.apiKey
      , appName = client.openrouter.appName
      }
  , ollama = client.ollama
  }

withOllamaBaseUrl : String -> Client -> Client
withOllamaBaseUrl url client =
  { openrouter = client.openrouter
  , ollama = { baseUrl = url }
  }

--------------------------------------------------------------------------------
-- Convenience model builders
--------------------------------------------------------------------------------

openrouterModel : String -> Model
openrouterModel id =
  { provider = OpenRouter, id = id }

ollamaModel : String -> Model
ollamaModel id =
  { provider = Ollama, id = id }

--------------------------------------------------------------------------------
-- Prompt helpers (public)
--------------------------------------------------------------------------------

toolPreamble : Template
toolPreamble =
  ''
    You must output exactly one JSON value and nothing else.

    Rules:
    - Output ONLY valid JSON.
    - No markdown.
    - No code fences.
    - No prose or explanations.
    - No leading or trailing text.
    - Do not add extra keys beyond the requested schema.
  ''

toolPostamble : Template
toolPostamble =
  ''
    Output ONLY JSON now.
  ''

--------------------------------------------------------------------------------
-- Public API
--------------------------------------------------------------------------------

ask : Client -> Request -> IO (Result Error Response)
ask client req =
  case req.model.provider of
    OpenRouter ->
      callOpenRouter client.openrouter req.model.id (Template.render req.prompt)

    Ollama ->
      callOllama client.ollama req.model.id (Template.render req.prompt)

json : Json.Decode a => Client -> Request -> IO (Result Error a)
json client req =
  prim_ioBind (ask client req) (\r ->
    case r of
      Err e ->
        prim_ioPure (Err e)

      Ok resp ->
        case Json.decode resp.text of
          Ok a ->
            prim_ioPure (Ok a)
          Err msg ->
            prim_ioPure (Err (DecodeError msg))
  )

tool : Json.Decode a => Client -> Request -> IO (Result Error a)
tool client req =
  let req2 = { req | prompt = toolPreamble <> req.prompt <> toolPostamble } in
  prim_ioBind (ask client req2) (\r ->
    case r of
      Err e ->
        prim_ioPure (Err e)

      Ok resp ->
        case extractJson resp.text of
          Err msg ->
            prim_ioPure (Err (DecodeError msg))

          Ok rawJson ->
            case Json.decode rawJson of
              Ok a ->
                prim_ioPure (Ok a)
              Err msg ->
                prim_ioPure (Err (DecodeError msg))
  )

--------------------------------------------------------------------------------
-- JSON extraction (internal)
--------------------------------------------------------------------------------

extractJson : String -> Result String String
extractJson s =
  extractJsonTrimmed (Str.trim s)

extractJsonTrimmed : String -> Result String String
extractJsonTrimmed t =
  case startsLikeJsonContainer t of
    True ->
      case validateJson t of
        Ok _ ->
          Ok t
        Err _ ->
          extractViaSlice t

    False ->
      extractViaSlice t

startsLikeJsonContainer : String -> Bool
startsLikeJsonContainer t =
  case Str.startsWith "{" t of
    True -> True
    False -> Str.startsWith "[" t

extractViaSlice : String -> Result String String
extractViaSlice t =
  case findJsonSlice t of
    Err _ ->
      Err (Str.append "Could not find JSON in response: " (snippet 240 t))
    Ok raw ->
      case validateJson raw of
        Ok _ -> Ok raw
        Err _ -> Err (Str.append "Could not parse JSON in response: " (snippet 240 raw))

validateJson : String -> Result String RawJson.Json
validateJson raw =
  RawJson.parse raw

findJsonSlice : String -> Result String String
findJsonSlice t =
  case firstJsonStart t of
    Nothing ->
      Err "no start"
    Just start ->
      case lastJsonEnd t of
        Nothing ->
          Err "no end"
        Just end ->
          case ltInt start end of
            True ->
              Ok (sliceInclusive start end t)
            False ->
              Err "invalid slice"

firstJsonStart : String -> Maybe Int
firstJsonStart t =
  minMaybe (Str.indexOf "{" t) (Str.indexOf "[" t)

lastJsonEnd : String -> Maybe Int
lastJsonEnd t =
  maxMaybe
    (lastIndexOfChar (prim_intToChar 125) t)  -- '}'
    (lastIndexOfChar (prim_intToChar 93) t)   -- ']'

lastIndexOfChar : Char -> String -> Maybe Int
lastIndexOfChar c s =
  lastIndexOfCharGo c (Str.toChars s) 0 Nothing

lastIndexOfCharGo : Char -> List Char -> Int -> Maybe Int -> Maybe Int
lastIndexOfCharGo c chars idx last =
  case chars of
    [] ->
      last
    Cons x xs ->
      case prim_eqInt (prim_charToInt x) (prim_charToInt c) of
        True ->
          lastIndexOfCharGo c xs (Int.add idx 1) (Just idx)
        False ->
          lastIndexOfCharGo c xs (Int.add idx 1) last

minMaybe : Maybe Int -> Maybe Int -> Maybe Int
minMaybe a b =
  case a of
    Nothing -> b
    Just x ->
      case b of
        Nothing -> a
        Just y ->
          case prim_leInt x y of
            True -> Just x
            False -> Just y

maxMaybe : Maybe Int -> Maybe Int -> Maybe Int
maxMaybe a b =
  case a of
    Nothing -> b
    Just x ->
      case b of
        Nothing -> a
        Just y ->
          case prim_leInt x y of
            True -> Just y
            False -> Just x

sliceInclusive : Int -> Int -> String -> String
sliceInclusive start end s =
  let len = Int.add (Int.sub end start) 1 in
  Str.take len (Str.drop start s)

ltInt : Int -> Int -> Bool
ltInt a b =
  case prim_leInt a b of
    True ->
      case prim_eqInt a b of
        True -> False
        False -> True
    False ->
      False

snippet : Int -> String -> String
snippet n s =
  case prim_leInt (Str.length s) n of
    True ->
      s
    False ->
      Str.append (Str.take n s) "â€¦"

--------------------------------------------------------------------------------
-- Provider implementations (v0 stubs)
--------------------------------------------------------------------------------

callOpenRouter : OpenRouterConfig -> String -> String -> IO (Result Error Response)
callOpenRouter cfg _ _ =
  case cfg.apiKey of
    Nothing ->
      prim_ioPure (Err Unauthorized)
    Just _ ->
      prim_ioPure (Err (ProviderError "OpenRouter: HTTP client not implemented (v0)."))

callOllama : OllamaConfig -> String -> String -> IO (Result Error Response)
callOllama cfg modelId prompt =
  case Str.startsWith "mock://" cfg.baseUrl of
    True ->
      prim_ioPure (mockOllama modelId prompt)
    False ->
      prim_ioPure (Err (ProviderError "Ollama: HTTP client not implemented (v0)."))

mockOllama : String -> String -> Result Error Response
mockOllama modelId prompt =
  case Str.eq modelId "mock-tool-wrapper" of
    True ->
      let pre = countOccurrences "You must output exactly one JSON value and nothing else." prompt in let post = countOccurrences "Output ONLY JSON now." prompt in
      Ok
        { text =
            Str.append
              (Str.append "[" (Str.fromInt pre))
              (Str.append (Str.append "," (Str.fromInt post)) "]")
        , usage = Nothing
        }

    False ->
      case Str.eq modelId "mock-pure" of
        True ->
          Ok { text = "{\"n\":1}", usage = Nothing }

        False ->
          case Str.eq modelId "mock-prose-prefix" of
            True ->
              Ok { text = "Sure.\n{\"n\":1}", usage = Nothing }

            False ->
              case Str.eq modelId "mock-prose-suffix" of
                True ->
                  Ok { text = "{\"n\":1}\nThanks!", usage = Nothing }

                False ->
                  case Str.eq modelId "mock-invalid" of
                    True ->
                      Ok { text = "Ok: {not json}", usage = Nothing }

                    False ->
                      case Str.eq modelId "mock-no-json" of
                        True ->
                          Ok { text = "No JSON here.", usage = Nothing }

                        False ->
                          Err (ProviderError "Unknown mock model id.")

countOccurrences : String -> String -> Int
countOccurrences needle haystack =
  case Str.isEmpty needle of
    True ->
      0
    False ->
      countOccurrencesFrom needle (Str.length needle) 0 haystack

countOccurrencesFrom : String -> Int -> Int -> String -> Int
countOccurrencesFrom needle needleLen acc s =
  case Str.indexOf needle s of
    Nothing ->
      acc
    Just i ->
      let next = Str.drop (Int.add i needleLen) s in
      countOccurrencesFrom needle needleLen (Int.add acc 1) next
