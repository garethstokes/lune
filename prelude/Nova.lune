module Nova exposing (
  openrouter,
  ollama,
  provider,
  providerId,
  showProvider,
  showError,

  -- Hooks
  NovaHooks,

  -- Client
  Client,
  newClient,
  defaultClient,
  withProvider,
  withModel,
  withOpenRouterKey,
  withOpenRouterBaseUrl,
  withOllamaBaseUrl,
  withHooks,
  withoutHooks,

  -- Prompt helpers
  toolPreamble,
  toolPostamble,
  extractJson,
  composeToolPrompt,

  -- Public API
  ask,
  json,
  tool,

  -- Streaming (architecture only)
  Stream,
  StreamStep(..),
  next,
  NovaEvent(..),
  showEvent,
  showNovaEvent,
  showStreamStep,
  showStreamResult,
  askStream,

  -- Tool execution (guarded + auditable)
  executeTool,
  showToolExecError
)

{-| Nova (v2): thin LLM decision engine surface for Lune.

Public APIs:
- `ask` returns raw text.
- `json` decodes JSON from the full response body.
- `tool` enforces "JSON only" via prompt wrappers and best-effort JSON extraction.

Internals are layered into:
- `Nova.Core` (types + provider registry)
- `Nova.Prompt` (prompt + JSON extraction)
- `Nova.Tool` (tool identity + schema + decoding)
- `Nova.Runtime` (tool execution guards)
- Streaming is simulated via chunking (no HTTP streaming yet).
-}

import Lune.Prelude exposing (Bool(..), Int, String, List(..), Maybe(..), Result(..), Unit, unit, Applicative(..), Monad(..))
import Lune.Int as Int
import Lune.String as Str
import Lune.Json as RawJson exposing (Json)
import Lune.Json.Decode as Decode exposing (DecodeError, PathItem(..))
import Lune.Json.Encode as Encode
import Nova.Core as Core exposing (Provider, Usage, Response, Error(..), Request, ProviderSettings, ProviderConfig, ProviderRegistry)
import Nova.Prompt as Prompt
import Nova.Tool as Tool exposing (ToolId, ToolSpec)
import Nova.Runtime as Runtime exposing (RuntimeConfig, ToolExecError(..))
import Json

openrouter : Provider
openrouter =
  Core.openrouter

ollama : Provider
ollama =
  Core.ollama

provider : String -> Provider
provider s =
  Core.Provider s

providerId : Provider -> String
providerId =
  Core.providerId

showProvider : Provider -> String
showProvider =
  providerId

showError : Error -> String
showError e =
  case e of
    NetworkError msg ->
      Str.append "NetworkError " msg

    RateLimited ->
      "RateLimited"

    Unauthorized ->
      "Unauthorized"

    BadRequest msg ->
      Str.append "BadRequest " msg

    ProviderError msg ->
      Str.append "ProviderError " msg

    DecodeError msg ->
      Str.append "DecodeError " msg

--------------------------------------------------------------------------------
-- Hooks
--------------------------------------------------------------------------------

type alias NovaHooks =
  { onTurn :
      { request : Request
      , response : Response
      }
      -> IO Unit

  , onToolStart :
      { tool : ToolId
      , input : Json
      }
      -> IO Unit

  , onToolFinish :
      { tool : ToolId
      , output : Json
      , durationMs : Int
      }
      -> IO Unit
  }

--------------------------------------------------------------------------------
-- Client
--------------------------------------------------------------------------------

type alias Client =
  { provider : Provider
  , model : String
  , providerConfig : ProviderConfig
  , providers : ProviderRegistry
  , hooks : Maybe NovaHooks
  }

newClient : ProviderRegistry -> Provider -> String -> Client
newClient providers provider model =
  { provider = provider
  , model = model
  , providerConfig = Core.defaultProviderConfig
  , providers = providers
  , hooks = Nothing
  }

defaultClient : Client
defaultClient =
  newClient Core.defaultProviderRegistry ollama "llama3"

withProvider : Provider -> Client -> Client
withProvider provider client =
  { provider = provider
  , model = client.model
  , providerConfig = client.providerConfig
  , providers = client.providers
  , hooks = client.hooks
  }

withModel : String -> Client -> Client
withModel model client =
  { provider = client.provider
  , model = model
  , providerConfig = client.providerConfig
  , providers = client.providers
  , hooks = client.hooks
  }

withHooks : NovaHooks -> Client -> Client
withHooks hooks client =
  { provider = client.provider
  , model = client.model
  , providerConfig = client.providerConfig
  , providers = client.providers
  , hooks = Just hooks
  }

withoutHooks : Client -> Client
withoutHooks client =
  { provider = client.provider
  , model = client.model
  , providerConfig = client.providerConfig
  , providers = client.providers
  , hooks = Nothing
  }

eqProvider : Provider -> Provider -> Bool
eqProvider a b =
  Str.eq (providerId a) (providerId b)

defaultSettings : ProviderSettings
defaultSettings =
  { baseUrl = ""
  , apiKey = Nothing
  , appName = Nothing
  }

getSettings : Provider -> ProviderConfig -> ProviderSettings
getSettings provider cfg =
  case Core.dictGet eqProvider provider cfg of
    Just s -> s
    Nothing -> defaultSettings

updateSettings : Provider -> (ProviderSettings -> ProviderSettings) -> Client -> Client
updateSettings provider f client =
  let current = getSettings provider client.providerConfig in
  let next = f current in
  { provider = client.provider
  , model = client.model
  , providerConfig = Core.dictInsert eqProvider provider next client.providerConfig
  , providers = client.providers
  , hooks = client.hooks
  }

withOpenRouterKey : String -> Client -> Client
withOpenRouterKey key =
  updateSettings openrouter (\s ->
    { baseUrl = s.baseUrl
    , apiKey = Just key
    , appName = s.appName
    }
  )

withOpenRouterBaseUrl : String -> Client -> Client
withOpenRouterBaseUrl url =
  updateSettings openrouter (\s ->
    { baseUrl = url
    , apiKey = s.apiKey
    , appName = s.appName
    }
  )

withOllamaBaseUrl : String -> Client -> Client
withOllamaBaseUrl url =
  updateSettings ollama (\s ->
    { baseUrl = url
    , apiKey = s.apiKey
    , appName = s.appName
    }
  )

--------------------------------------------------------------------------------
-- Prompt helpers (public)
--------------------------------------------------------------------------------

toolPreamble : String
toolPreamble =
  Prompt.toolPreamble

toolPostamble : String
toolPostamble =
  Prompt.toolPostamble

extractJson : String -> Result Error String
extractJson =
  Prompt.extractJson

composeToolPrompt : ToolSpec a -> String -> String
composeToolPrompt =
  Prompt.composeToolPrompt

--------------------------------------------------------------------------------
-- Public API
--------------------------------------------------------------------------------

askRaw : Client -> String -> IO (Result Error Response)
askRaw client prompt =
  let request =
    { provider = client.provider
    , model = client.model
    , prompt = prompt
    } in
  prim_ioBind
    (Core.callProvider client.providers client.providerConfig client.provider client.model prompt)
    (\r ->
      case r of
        Err e ->
          prim_ioPure (Err e)

        Ok response ->
          case client.hooks of
            Nothing ->
              prim_ioPure (Ok response)

            Just hooks ->
              prim_ioBind (hooks.onTurn { request = request, response = response }) (\_ ->
                prim_ioPure (Ok response)
              )
    )

ask : Client -> String -> IO (Result Error String)
ask client prompt =
  prim_ioBind (askRaw client prompt) (\r ->
    case r of
      Err e ->
        prim_ioPure (Err e)

      Ok response ->
        prim_ioPure (Ok response.text)
  )

json : Json.Decode a => Client -> String -> IO (Result Error a)
json client prompt =
  prim_ioBind (askRaw client prompt) (\r ->
    case r of
      Err e ->
        prim_ioPure (Err e)

      Ok response ->
        case Json.decodeDetailed response.text of
          Ok a ->
            prim_ioPure (Ok a)

          Err decodeErr ->
            prim_ioPure (Err (Core.DecodeError (formatDecodeError decodeErr)))
  )

tool : Json.Decode a => Client -> String -> IO (Result Error a)
tool client prompt =
  let wrapped =
    Str.unlines
      [ toolPreamble
      , ""
      , prompt
      , ""
      , toolPostamble
      ] in
  prim_ioBind (askRaw client wrapped) (\r ->
    case r of
      Err e ->
        prim_ioPure (Err e)

      Ok response ->
        case extractJson response.text of
          Err e ->
            prim_ioPure (Err e)

          Ok rawJson ->
            case Json.decodeDetailed rawJson of
              Ok a ->
                prim_ioPure (Ok a)

              Err decodeErr ->
                prim_ioPure (Err (Core.DecodeError (formatDecodeError decodeErr)))
  )

formatDecodeError : DecodeError -> String
formatDecodeError err =
  case err.path of
    [] ->
      err.message

    _ ->
      Str.append err.message (Str.append " at " (pathToString err.path))

pathToString : List PathItem -> String
pathToString path =
  pathToStringGo "$" path

pathToStringGo : String -> List PathItem -> String
pathToStringGo acc items =
  case items of
    [] ->
      acc

    Cons item rest ->
      pathToStringGo (Str.append acc (pathItemToString item)) rest

pathItemToString : PathItem -> String
pathItemToString item =
  case item of
    Field name ->
      Str.append "." name

    Index i ->
      Str.append "[" (Str.append (Str.fromInt i) "]")

--------------------------------------------------------------------------------
-- Streaming (architecture only)
--------------------------------------------------------------------------------

type Stream a =
  Stream (IO (Result Error (StreamStep a)))

type StreamStep a =
  StreamEnd
  | StreamYield a (Stream a)

next : Stream a -> IO (Result Error (StreamStep a))
next stream =
  case stream of
    Stream io ->
      io

streamFromList : List a -> Stream a
streamFromList xs =
  Stream (prim_ioPure (Ok (stepFromList xs)))

stepFromList : List a -> StreamStep a
stepFromList xs =
  case xs of
    [] ->
      StreamEnd

    Cons x rest ->
      StreamYield x (streamFromList rest)

type NovaEvent =
  TextDelta String
  | ToolCallDelta Json
  | ToolCallComplete Json
  | UsageFinal Usage

showNovaEvent : NovaEvent -> String
showNovaEvent ev =
  case ev of
    TextDelta s ->
      Str.append "TextDelta " s

    ToolCallDelta _ ->
      "ToolCallDelta"

    ToolCallComplete _ ->
      "ToolCallComplete"

    UsageFinal _ ->
      "UsageFinal"

showEvent : NovaEvent -> String
showEvent =
  showNovaEvent

showStreamStep : (a -> String) -> StreamStep a -> String
showStreamStep showA step =
  case step of
    StreamEnd ->
      "StreamEnd"

    StreamYield a _ ->
      Str.append "StreamYield " (showA a)

showStreamResult : (e -> String) -> (a -> String) -> Result e (StreamStep a) -> String
showStreamResult showE showA r =
  case r of
    Err e ->
      Str.append "StreamErr " (showE e)

    Ok step ->
      showStreamStep showA step

askStream : Client -> String -> Stream NovaEvent
askStream client prompt =
  Stream
    ( prim_ioBind (askRaw client prompt) (\r ->
        case r of
          Err e ->
            prim_ioPure (Err e)

          Ok response ->
            prim_ioPure (Ok (stepFromList (responseToEvents response)))
      )
    )

responseToEvents : Response -> List NovaEvent
responseToEvents response =
  let chunks = chunkText 24 response.text in
  let textEvents = listMap TextDelta chunks in
  case response.usage of
    Nothing ->
      textEvents

    Just usage ->
      listAppend textEvents (Cons (UsageFinal usage) [])

chunkText : Int -> String -> List String
chunkText chunkSize s =
  case prim_leInt chunkSize 0 of
    True ->
      case Str.isEmpty s of
        True -> []
        False -> Cons s []

    False ->
      case prim_leInt (Str.length s) chunkSize of
        True ->
          case Str.isEmpty s of
            True -> []
            False -> Cons s []

        False ->
          Cons (Str.take chunkSize s) (chunkText chunkSize (Str.drop chunkSize s))

listMap : (a -> b) -> List a -> List b
listMap f xs =
  case xs of
    [] ->
      []

    Cons x rest ->
      Cons (f x) (listMap f rest)

listAppend : List a -> List a -> List a
listAppend xs ys =
  case xs of
    [] ->
      ys

    Cons x rest ->
      Cons x (listAppend rest ys)

--------------------------------------------------------------------------------
-- Tool execution (guarded + auditable)
--------------------------------------------------------------------------------

executeTool :
  Client
  -> RuntimeConfig
  -> ToolSpec a
  -> (a -> Json)
  -> (b -> Json)
  -> (a -> IO (Result ToolExecError b))
  -> a
  -> IO (Result ToolExecError b)
executeTool client runtimeConfig spec encodeInput encodeOutput exec input =
  do
    let inputJson = encodeInput input
    case client.hooks of
      Nothing ->
        pure unit

      Just hooks ->
        hooks.onToolStart { tool = spec.id, input = inputJson }

    t0 <- prim_timeNowMicros
    result <- Runtime.executeWithGuardsUsing runtimeConfig spec exec input
    t1 <- prim_timeNowMicros
    let durationMs = Int.div (Int.sub t1 t0) 1000
    let outputJson =
      case result of
        Ok b ->
          encodeOutput b

        Err e ->
          encodeToolExecError e

    case client.hooks of
      Nothing ->
        pure unit

      Just hooks ->
        hooks.onToolFinish
          { tool = spec.id
          , output = outputJson
          , durationMs = durationMs
          }

    pure result

encodeToolExecError : ToolExecError -> Json
encodeToolExecError e =
  Encode.object
    [ { key = "error"
      , value = Encode.string (toolExecErrorToString e)
      }
    ]

toolExecErrorToString : ToolExecError -> String
toolExecErrorToString e =
  case e of
    ToolNotAllowed id ->
      Str.append "ToolNotAllowed " (Tool.toolIdToString id)

    ApprovalRequired id ->
      Str.append "ApprovalRequired " (Tool.toolIdToString id)

    ToolTimedOut id ->
      Str.append "ToolTimedOut " (Tool.toolIdToString id)

    MaxTurnsExceeded n ->
      Str.append "MaxTurnsExceeded " (Str.fromInt n)

    ToolNotImplemented id ->
      Str.append "ToolNotImplemented " (Tool.toolIdToString id)

    ToolFailed msg ->
      Str.append "ToolFailed " msg

showToolExecError : ToolExecError -> String
showToolExecError =
  toolExecErrorToString
