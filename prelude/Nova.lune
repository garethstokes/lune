module Nova exposing (
  openrouter
  , ollama
  , provider
  , providerId
  , providerEq
  , showProvider
  , showError
  , showAskResult
  , showJsonResult
  , NovaHooks
  , Client
  , newClient
  , defaultClient
  , withProvider
  , withModel
  , withOpenRouterKey
  , withOpenRouterBaseUrl
  , withOllamaBaseUrl
  , withHooks
  , withoutHooks
  , toolPreamble
  , toolPostamble
  , extractJson
  , composeToolPrompt
  , ask
  , json
  , tool
  , Stream
  , StreamStep(..)
  , next
  , NovaEvent(..)
  , showEvent
  , showNovaEvent
  , showStreamStep
  , showStreamResult
  , askStream
  , executeTool
  , showToolExecResult
  , showToolExecError
)

import Lune.Prelude exposing (
  Bool(..)
  , Int
  , String
  , List(..)
  , Maybe(..)
  , Result(..)
  , Unit
  , unit
  , Task(..)
  , Applicative(..)
  , Monad(..)
)
import Lune.IO as IO
import Lune.Task as Task
import Lune.Int as Int
import Lune.String as Str
import Lune.Json as RawJson exposing (Json)
import Lune.Json.Decode as Decode exposing (DecodeError, PathItem(..))
import Lune.Json.Encode as Encode
import Nova.Core as Core exposing (
  Provider
  , Usage
  , Response
  , Error(..)
  , Request
  , ProviderSettings
  , ProviderConfig
  , ProviderRegistry
)
import Nova.Prompt as Prompt
import Nova.Tool as Tool exposing (ToolId, ToolSpec)
import Nova.Runtime as Runtime exposing (RuntimeConfig, ToolExecError(..))
import Json

-- Hooks

-- Client

-- Prompt helpers

-- Public API

-- Streaming (architecture only)

-- Tool execution (guarded + auditable)

{-| Nova (v2): thin LLM decision engine surface for Lune.

Public APIs:
- `ask` returns raw text.
- `json` decodes JSON from the full response body.
- `tool` enforces "JSON only" via prompt wrappers and best-effort JSON extraction.

Internals are layered into:
- `Nova.Core` (types + provider registry)
- `Nova.Prompt` (prompt + JSON extraction)
- `Nova.Tool` (tool identity + schema + decoding)
- `Nova.Runtime` (tool execution guards)
- Streaming is simulated via chunking (no HTTP streaming yet).
-}

openrouter : Provider
openrouter = Core.openrouter

ollama : Provider
ollama = Core.ollama

provider : String -> Provider
provider s = Core.Provider s

providerId : Provider -> String
providerId = Core.providerId

providerEq : Provider -> Provider -> Bool
providerEq = eqProvider

showProvider : Provider -> String
showProvider = providerId

showError : Error -> String
showError e =
  case e of
    NetworkError msg ->
      Str.append "NetworkError " msg
    RateLimited ->
      "RateLimited"
    Unauthorized ->
      "Unauthorized"
    BadRequest msg ->
      Str.append "BadRequest " msg
    ProviderError msg ->
      Str.append "ProviderError " msg
    DecodeError msg ->
      Str.append "DecodeError " msg

showAskResult : Result Error String -> String
showAskResult r =
  case r of
    Err e ->
      showError e
    Ok s ->
      s

showJsonResult : Result Error Json -> String
showJsonResult r =
  case r of
    Err e ->
      showError e
    Ok j ->
      RawJson.stringify j

--------------------------------------------------------------------------------
-- Hooks
--------------------------------------------------------------------------------

type alias NovaHooks =
  { onTurn : { request : Request
  , response : Response
  } -> Task Unit Unit
  , onToolStart : { tool : ToolId
  , input : Json
  } -> Task Unit Unit
  , onToolFinish : { tool : ToolId
  , output : Json
  , durationMs : Int
  }
    -> Task Unit Unit
  }

--------------------------------------------------------------------------------
-- Client
--------------------------------------------------------------------------------

type alias Client =
  { provider : Provider
  , model : String
  , providerConfig : ProviderConfig
  , providers : ProviderRegistry
  , hooks : Maybe NovaHooks
  }

newClient : ProviderRegistry -> Provider -> String -> Client
newClient providers provider model =
  { provider = provider
  , model = model
  , providerConfig = Core.defaultProviderConfig
  , providers = providers
  , hooks = Nothing
  }

defaultClient : Client
defaultClient = newClient Core.defaultProviderRegistry ollama "llama3"

withProvider : Provider -> Client -> Client
withProvider provider client =
  { provider = provider
  , model = client.model
  , providerConfig = client.providerConfig
  , providers = client.providers
  , hooks = client.hooks
  }

withModel : String -> Client -> Client
withModel model client =
  { provider = client.provider
  , model = model
  , providerConfig = client.providerConfig
  , providers = client.providers
  , hooks = client.hooks
  }

withHooks : NovaHooks -> Client -> Client
withHooks hooks client =
  { provider = client.provider
  , model = client.model
  , providerConfig = client.providerConfig
  , providers = client.providers
  , hooks = Just hooks
  }

withoutHooks : Client -> Client
withoutHooks client =
  { provider = client.provider
  , model = client.model
  , providerConfig = client.providerConfig
  , providers = client.providers
  , hooks = Nothing
  }

eqProvider : Provider -> Provider -> Bool
eqProvider a b = Str.eq (providerId a) (providerId b)

defaultSettings : ProviderSettings
defaultSettings = { baseUrl = "", apiKey = Nothing, appName = Nothing }

getSettings : Provider -> ProviderConfig -> ProviderSettings
getSettings provider cfg =
  case Core.dictGet eqProvider provider cfg of
    Just s ->
      s
    Nothing ->
      defaultSettings

updateSettings :
    Provider -> (ProviderSettings -> ProviderSettings) -> Client -> Client
updateSettings provider f client =
  let
    current = getSettings provider client.providerConfig
    next = f current
  in
    { provider = client.provider
    , model = client.model
    , providerConfig =
      Core.dictInsert eqProvider provider next client.providerConfig
    , providers = client.providers
    , hooks = client.hooks
    }

withOpenRouterKey : String -> Client -> Client
withOpenRouterKey key =
  updateSettings
    openrouter
    (\s -> { baseUrl = s.baseUrl, apiKey = Just key, appName = s.appName })

withOpenRouterBaseUrl : String -> Client -> Client
withOpenRouterBaseUrl url =
  updateSettings
    openrouter
    (\s -> { baseUrl = url, apiKey = s.apiKey, appName = s.appName })

withOllamaBaseUrl : String -> Client -> Client
withOllamaBaseUrl url =
  updateSettings
    ollama
    (\s -> { baseUrl = url, apiKey = s.apiKey, appName = s.appName })

--------------------------------------------------------------------------------
-- Prompt helpers (public)
--------------------------------------------------------------------------------

toolPreamble : String
toolPreamble = Prompt.toolPreamble

toolPostamble : String
toolPostamble = Prompt.toolPostamble

extractJson : String -> Result Error String
extractJson = Prompt.extractJson

composeToolPrompt : ToolSpec a -> String -> String
composeToolPrompt = Prompt.composeToolPrompt

--------------------------------------------------------------------------------
-- Public API
--------------------------------------------------------------------------------

askRaw : Client -> String -> Task Error Response
askRaw client prompt =
  let
    request =
      { provider = client.provider, model = client.model, prompt = prompt }
  in
    Task.andThen
      (liftResult
        (Core.callProvider
          client.providers
          client.providerConfig
          client.provider
          client.model
          prompt))
      (\response ->
        case client.hooks of
          Nothing ->
            Task.succeed response
          Just hooks ->
            Task.andThen
              (Task.mapError
                (\_ -> Core.ProviderError "hook failed")
                (hooks.onTurn
                  { request = request, response = response }))
              (\_ -> Task.succeed response))

liftResult : IO (Result e a) -> Task e a
liftResult io = Task io

ask : Client -> String -> Task Error String
ask client prompt = Task.map (\response -> response.text) (askRaw client prompt)

json : Json.Decode a => Client -> String -> Task Error a
json client prompt =
  Task.andThen
    (askRaw client prompt)
    (\response ->
      case Json.decodeDetailed response.text of
        Ok a ->
          Task.succeed a
        Err decodeErr ->
          Task.fail (Core.DecodeError (formatDecodeError decodeErr)))

tool : Json.Decode a => Client -> String -> Task Error a
tool client prompt =
  let
    wrapped = Str.unlines [toolPreamble, "", prompt, "", toolPostamble]
  in
    Task.andThen
      (askRaw client wrapped)
      (\response ->
        case extractJson response.text of
          Err e ->
            Task.fail e
          Ok rawJson ->
            case Json.decodeDetailed rawJson of
              Ok a ->
                Task.succeed a
              Err decodeErr ->
                Task.fail (Core.DecodeError (formatDecodeError decodeErr)))

formatDecodeError : DecodeError -> String
formatDecodeError err =
  case err.path of
    [] ->
      err.message
    _ ->
      Str.append err.message (Str.append " at " (pathToString err.path))

pathToString : List PathItem -> String
pathToString path = pathToStringGo "$" path

pathToStringGo : String -> List PathItem -> String
pathToStringGo acc items =
  case items of
    [] ->
      acc
    Cons item rest ->
      pathToStringGo (Str.append acc (pathItemToString item)) rest

pathItemToString : PathItem -> String
pathItemToString item =
  case item of
    Field name ->
      Str.append "." name
    Index i ->
      Str.append "[" (Str.append (Str.fromInt i) "]")

--------------------------------------------------------------------------------
-- Streaming (architecture only)
--------------------------------------------------------------------------------

type Stream a =
  Stream IO Result Error (StreamStep a)

type StreamStep a =
  StreamEnd
  | StreamYield a Stream a

next : Stream a -> IO (Result Error (StreamStep a))
next stream =
  case stream of
    Stream io ->
      io

streamFromList : List a -> Stream a
streamFromList xs = Stream (IO.pure (Ok (stepFromList xs)))

stepFromList : List a -> StreamStep a
stepFromList xs =
  case xs of
    [] ->
      StreamEnd
    Cons x rest ->
      StreamYield x (streamFromList rest)

type NovaEvent =
  TextDelta String
  | ToolCallDelta Json
  | ToolCallComplete Json
  | UsageFinal Usage

showNovaEvent : NovaEvent -> String
showNovaEvent ev =
  case ev of
    TextDelta s ->
      Str.append "TextDelta " s
    ToolCallDelta _ ->
      "ToolCallDelta"
    ToolCallComplete _ ->
      "ToolCallComplete"
    UsageFinal _ ->
      "UsageFinal"

showEvent : NovaEvent -> String
showEvent = showNovaEvent

showStreamStep : (a -> String) -> StreamStep a -> String
showStreamStep showA step =
  case step of
    StreamEnd ->
      "StreamEnd"
    StreamYield a _ ->
      Str.append "StreamYield " (showA a)

showStreamResult :
    (e -> String) -> (a -> String) -> Result e (StreamStep a) -> String
showStreamResult showE showA r =
  case r of
    Err e ->
      Str.append "StreamErr " (showE e)
    Ok step ->
      showStreamStep showA step

askStream : Client -> String -> Stream NovaEvent
askStream client prompt =
  Stream
    (IO.andThen
      (Task.attempt (askRaw client prompt))
      (\r ->
        case r of
          Err e ->
            IO.pure (Err e)
          Ok response ->
            IO.pure (Ok (stepFromList (responseToEvents response)))))

responseToEvents : Response -> List NovaEvent
responseToEvents response =
  let
    chunks = chunkText 24 response.text
    textEvents = listMap TextDelta chunks
  in
    case response.usage of
      Nothing ->
        textEvents
      Just usage ->
        listAppend textEvents [UsageFinal usage]

chunkText : Int -> String -> List String
chunkText chunkSize s =
  case prim_leInt chunkSize 0 of
    True ->
      case Str.isEmpty s of
        True ->
          []
        False ->
          [s]
    False ->
      case prim_leInt (Str.length s) chunkSize of
        True ->
          case Str.isEmpty s of
            True ->
              []
            False ->
              [s]
        False ->
          Cons
            (Str.take chunkSize s)
            (chunkText chunkSize (Str.drop chunkSize s))

listMap : (a -> b) -> List a -> List b
listMap f xs =
  case xs of
    [] ->
      []
    Cons x rest ->
      Cons (f x) (listMap f rest)

listAppend : List a -> List a -> List a
listAppend xs ys =
  case xs of
    [] ->
      ys
    Cons x rest ->
      Cons x (listAppend rest ys)

--------------------------------------------------------------------------------
-- Tool execution (guarded + auditable)
--------------------------------------------------------------------------------

executeTool :
    Client
      -> RuntimeConfig
      -> ToolSpec a
      -> (a -> Json)
      -> (b -> Json)
      -> (a -> Task ToolExecError b)
      -> a
      -> Task ToolExecError b
executeTool client runtimeConfig spec encodeInput encodeOutput exec input =
  do
    let inputJson = encodeInput input
    case client.hooks of
      Nothing ->
        Task.succeed unit
      Just hooks ->
        Task.mapError
          (\_ -> ToolFailed "hook failed")
          (hooks.onToolStart
            { tool = spec.id, input = inputJson })

    t0 <- Task.fromIO prim_timeNowMicros
    result <-
      Task.fromIO
        (Task.attempt
          (Runtime.executeWithGuardsUsing runtimeConfig spec exec input))
    t1 <- Task.fromIO prim_timeNowMicros
    let durationMs = Int.div (Int.sub t1 t0) 1000
    let outputJson =
      case result of
        Ok b ->
          encodeOutput b
        Err e ->
          encodeToolExecError e

    case client.hooks of
      Nothing ->
        Task.succeed unit
      Just hooks ->
        Task.mapError
          (\_ -> ToolFailed "hook failed")
          (hooks.onToolFinish
            { tool = spec.id, output = outputJson, durationMs = durationMs })

    case result of
      Ok b ->
        Task.succeed b
      Err e ->
        Task.fail e

encodeToolExecError : ToolExecError -> Json
encodeToolExecError e =
  Encode.object
    [{ key = "error", value = Encode.string (toolExecErrorToString e) }]

toolExecErrorToString : ToolExecError -> String
toolExecErrorToString e =
  case e of
    ToolNotAllowed id ->
      Str.append "ToolNotAllowed " (Tool.toolIdToString id)
    ApprovalRequired id ->
      Str.append "ApprovalRequired " (Tool.toolIdToString id)
    ToolTimedOut id ->
      Str.append "ToolTimedOut " (Tool.toolIdToString id)
    MaxTurnsExceeded n ->
      Str.append "MaxTurnsExceeded " (Str.fromInt n)
    ToolNotImplemented id ->
      Str.append "ToolNotImplemented " (Tool.toolIdToString id)
    ToolFailed msg ->
      Str.append "ToolFailed " msg

showToolExecResult : Result ToolExecError Int -> String
showToolExecResult r =
  case r of
    Ok n ->
      Str.append "Ok " (Str.fromInt n)
    Err e ->
      Str.append "Err " (showToolExecError e)

showToolExecError : ToolExecError -> String
showToolExecError = toolExecErrorToString
