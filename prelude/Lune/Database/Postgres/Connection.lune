module Lune.Database.Postgres.Connection exposing (
  PgConn,
  connect,
  connectWithPassword,
  close,
  sendQuery,
  readBackendMessage
)

{-| PostgreSQL connection management.

Handles TLS connection establishment, the startup/authentication handshake,
and provides a thin wrapper for sending queries and reading responses.

Example:
```
conn <- Connection.connect "localhost" 5432 "mydb" "myuser"
-- use conn with Query module
Connection.close conn
```
-}

import Lune.Prelude exposing (IO, Result(..), Unit, List(..), Int, String, Maybe(..), Bool(..), Monad(..))
import Lune.Bytes as Bytes exposing (Bytes)
import Lune.Net.Tls as Tls exposing (TlsConn)
import Lune.IO as IO
import Lune.Task as Task exposing (Task)
import Lune.String as Str
import Lune.Database.Postgres.Protocol as Protocol exposing (FrontendMessage(..), BackendMessage(..), TransactionStatus(..), PgError)

type alias PgConn =
  { tlsConn : TlsConn
  , backendPid : Int
  , backendSecret : Int
  }

-- | Connect to PostgreSQL over TLS without a password (trust/peer auth)
connect : String -> Int -> String -> String -> Task PgError PgConn
connect host port database user =
  Task
    ( do
        connResult <- Tls.connect host port
        case connResult of
          Err _ ->
            IO.pure
              (Err { severity = "FATAL", code = "08001", message = "TLS connection failed" })
          Ok tlsConn ->
            do
              sendResult <-
                Tls.sendBytes tlsConn
                  <| Protocol.encodeMessage (StartupMessage user database)
              case sendResult of
                Err _ ->
                  IO.pure
                    ( Err
                        { severity = "FATAL"
                        , code = "08001"
                        , message = "Failed to send startup message"
                        }
                    )
                Ok _ -> Task.attempt (handshake tlsConn Nothing)
    )

-- | Connect to PostgreSQL over TLS with a password
connectWithPassword : String -> Int -> String -> String -> String -> Task PgError PgConn
connectWithPassword host port database user password =
  Task
    ( do
        connResult <- Tls.connect host port
        case connResult of
          Err _ ->
            IO.pure
              (Err { severity = "FATAL", code = "08001", message = "TLS connection failed" })
          Ok tlsConn ->
            do
              sendResult <-
                Tls.sendBytes tlsConn
                  <| Protocol.encodeMessage (StartupMessage user database)
              case sendResult of
                Err _ ->
                  IO.pure
                    ( Err
                        { severity = "FATAL"
                        , code = "08001"
                        , message = "Failed to send startup message"
                        }
                    )
                Ok _ -> Task.attempt (handshake tlsConn (Just password))
    )

-- Handshake: read messages until ReadyForQuery
handshake : TlsConn -> Maybe String -> Task PgError PgConn
handshake tlsConn maybePassword =
  handshakeLoop tlsConn maybePassword 0 0

handshakeLoop : TlsConn -> Maybe String -> Int -> Int -> Task PgError PgConn
handshakeLoop tlsConn maybePassword pid secret =
  Task.andThen
    ( Task.mapError
        (\e -> { severity = "FATAL", code = "08001", message = e })
        (Protocol.readMessage tlsConn)
    )
    (\msg -> handleHandshakeMsg tlsConn maybePassword pid secret msg)

handleHandshakeMsg :
  TlsConn -> Maybe String -> Int -> Int -> BackendMessage -> Task PgError PgConn
handleHandshakeMsg tlsConn maybePassword pid secret msg =
  case msg of
    AuthenticationOk ->
      handshakeLoop tlsConn maybePassword pid secret
    AuthenticationCleartextPassword ->
      handleCleartextAuth tlsConn maybePassword pid secret
    ErrorResponse pgErr ->
      Task
        ( do
            _ <- Tls.close tlsConn
            IO.pure (Err pgErr)
        )
    BackendKeyData newPid newSecret ->
      handshakeLoop tlsConn maybePassword newPid newSecret
    ParameterStatus _ _ ->
      handshakeLoop tlsConn maybePassword pid secret
    ReadyForQuery _ ->
      Task.succeed { tlsConn = tlsConn, backendPid = pid, backendSecret = secret }
    _ ->
      handshakeLoop tlsConn maybePassword pid secret

handleCleartextAuth : TlsConn -> Maybe String -> Int -> Int -> Task PgError PgConn
handleCleartextAuth tlsConn maybePassword pid secret =
  case maybePassword of
    Nothing ->
      Task
        ( do
            _ <- Tls.close tlsConn
            IO.pure
              ( Err
                  { severity = "FATAL"
                  , code = "28P01"
                  , message = "Server requires password but none provided"
                  }
              )
        )
    Just pw ->
      Task
        ( do
            sendResult <-
              Tls.sendBytes tlsConn <| Protocol.encodeMessage (PasswordMessage pw)
            case sendResult of
              Err _ ->
                do
                  _ <- Tls.close tlsConn
                  IO.pure
                    ( Err
                        { severity = "FATAL"
                        , code = "08001"
                        , message = "Failed to send password"
                        }
                    )
              Ok _ -> Task.attempt (handshakeLoop tlsConn maybePassword pid secret)
        )

-- | Close a PostgreSQL connection gracefully
close : PgConn -> Task PgError Unit
close pg =
  Task
    ( do
        _ <- Tls.sendBytes pg.tlsConn (Protocol.encodeMessage Terminate)
        closeResult <- Tls.close pg.tlsConn
        case closeResult of
          Err _ ->
            IO.pure
              (Err { severity = "ERROR", code = "08003", message = "Failed to close connection" })
          Ok _ -> IO.pure (Ok Unit)
    )

-- | Send a query message over the connection
sendQuery : PgConn -> String -> Task PgError Unit
sendQuery pg sql =
  Task
    ( do
        sendResult <- Tls.sendBytes pg.tlsConn (Protocol.encodeMessage (Query sql))
        case sendResult of
          Err _ ->
            IO.pure
              (Err { severity = "ERROR", code = "08003", message = "Failed to send query" })
          Ok _ -> IO.pure (Ok Unit)
    )

-- | Read one backend message from the connection
readBackendMessage : PgConn -> Task PgError BackendMessage
readBackendMessage pg =
  Task.mapError
    (\e -> { severity = "ERROR", code = "XX000", message = e })
    (Protocol.readMessage pg.tlsConn)
