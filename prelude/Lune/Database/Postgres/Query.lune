module Lune.Database.Postgres.Query exposing (
  query,
  execute,
  begin,
  commit,
  rollback,
  transaction
)

{-| PostgreSQL query execution over the wire protocol.

Provides query/execute for running SQL and transaction management,
all implemented in pure Lune over the Protocol and Connection modules.

Example:
```
rows <- PgQuery.query conn "SELECT id, name FROM users"
-- rows : List (List (Maybe Bytes))
-- each row is a list of nullable column values
```
-}

import Lune.Prelude exposing (Result(..), Unit, List(..), Int, String, Maybe(..), Bool(..))
import Lune.Task as Task exposing (Task)
import Lune.Bytes as Bytes exposing (Bytes)
import Lune.String as Str
import Lune.Int as Int
import Lune.List as List
import Lune.Database.Postgres.Connection as Conn exposing (PgConn)
import Lune.Database.Postgres.Protocol as Protocol exposing (BackendMessage(..), PgError)

-- | Execute a SELECT query and return all rows
-- Each row is a list of nullable byte values (Nothing for SQL NULL)
query : PgConn -> String -> Task PgError (List (List (Maybe Bytes)))
query pg sql =
  Task.andThen (Conn.sendQuery pg sql) (\_ -> collectQueryResults pg Nil)

-- | Execute a statement (INSERT/UPDATE/DELETE) and return affected row count
execute : PgConn -> String -> Task PgError Int
execute pg sql =
  Task.andThen (Conn.sendQuery pg sql) (\_ -> readExecuteResult pg)

-- | Begin a transaction
begin : PgConn -> Task PgError Unit
begin pg =
  Task.andThen (execute pg "BEGIN") (\_ -> Task.succeed Unit)

-- | Commit a transaction
commit : PgConn -> Task PgError Unit
commit pg =
  Task.andThen (execute pg "COMMIT") (\_ -> Task.succeed Unit)

-- | Rollback a transaction
rollback : PgConn -> Task PgError Unit
rollback pg =
  Task.andThen (execute pg "ROLLBACK") (\_ -> Task.succeed Unit)

-- | Execute an action inside a transaction
-- Commits on Ok result, rolls back on Err
transaction : PgConn -> (PgConn -> Task PgError a) -> Task PgError a
transaction pg action =
  Task.andThen (begin pg) (\_ ->
    Task.onError
      (Task.andThen (action pg) (\a ->
        Task.andThen (commit pg) (\_ -> Task.succeed a)))
      (\e ->
        Task.andThen (rollback pg) (\_ -> Task.fail e)))

-- Internal: collect rows from a SELECT query response
-- Reads messages until ReadyForQuery, accumulating DataRow values
collectQueryResults : PgConn -> List (List (Maybe Bytes)) -> Task PgError (List (List (Maybe Bytes)))
collectQueryResults pg acc =
  Task.andThen (Conn.readBackendMessage pg) (\msg -> handleQueryMsg pg acc msg)

handleQueryMsg : PgConn -> List (List (Maybe Bytes)) -> BackendMessage -> Task PgError (List (List (Maybe Bytes)))
handleQueryMsg pg acc msg =
  case msg of
    RowDescription _ ->
      collectQueryResults pg acc
    DataRow cols ->
      collectQueryResults pg (Cons cols acc)
    CommandComplete _ ->
      collectQueryResults pg acc
    ReadyForQuery _ ->
      Task.succeed (List.reverse acc)
    EmptyQueryResponse ->
      collectQueryResults pg acc
    ErrorResponse pgErr ->
      drainUntilReady pg pgErr
    NoticeResponse _ ->
      collectQueryResults pg acc
    _ ->
      collectQueryResults pg acc

-- Internal: read messages for an execute (non-SELECT) query
readExecuteResult : PgConn -> Task PgError Int
readExecuteResult pg =
  readExecuteLoop pg 0

readExecuteLoop : PgConn -> Int -> Task PgError Int
readExecuteLoop pg rowCount =
  Task.andThen (Conn.readBackendMessage pg) (\msg -> handleExecuteMsg pg rowCount msg)

handleExecuteMsg : PgConn -> Int -> BackendMessage -> Task PgError Int
handleExecuteMsg pg rowCount msg =
  case msg of
    CommandComplete tag ->
      readExecuteLoop pg (parseRowCount tag)
    ReadyForQuery _ ->
      Task.succeed rowCount
    ErrorResponse pgErr ->
      drainUntilReady pg pgErr
    EmptyQueryResponse ->
      readExecuteLoop pg 0
    NoticeResponse _ ->
      readExecuteLoop pg rowCount
    RowDescription _ ->
      readExecuteLoop pg rowCount
    DataRow _ ->
      readExecuteLoop pg rowCount
    _ ->
      readExecuteLoop pg rowCount

-- Internal: drain messages until ReadyForQuery after an error
drainUntilReady : PgConn -> PgError -> Task PgError a
drainUntilReady pg pgErr =
  Task.onError
    (Task.andThen (Conn.readBackendMessage pg) (\msg ->
      case msg of
        ReadyForQuery _ -> Task.fail pgErr
        _ -> drainUntilReady pg pgErr))
    (\_ -> Task.fail pgErr)

-- Parse row count from a CommandComplete tag
-- Tags look like: "SELECT 5", "INSERT 0 3", "UPDATE 10", "DELETE 2", "BEGIN", "COMMIT"
parseRowCount : String -> Int
parseRowCount tag =
  parseRowCountFromBytes (Bytes.toList (Bytes.fromString tag))

parseRowCountFromBytes : List Int -> Int
parseRowCountFromBytes bytes =
  extractLastNumber (List.reverse bytes) 0 1

-- Extract the trailing number from a reversed byte list
-- Walks backwards: digits contribute to the number, stops at first non-digit
extractLastNumber : List Int -> Int -> Int -> Int
extractLastNumber revBytes acc multiplier =
  case revBytes of
    Nil -> acc
    Cons b rest ->
      case isDigit b of
        True ->
          extractLastNumber rest (Int.add acc (Int.mul (Int.sub b 48) multiplier)) (Int.mul multiplier 10)
        False -> acc

isDigit : Int -> Bool
isDigit b =
  case Int.gte b 48 of
    True -> Int.lte b 57
    False -> False
