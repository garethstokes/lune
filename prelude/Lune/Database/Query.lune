module Lune.Database.Query exposing (
  Table,
  Column,
  Query,
  Order(..),
  QueryType(..),
  Condition,
  Assignment,
  table,
  column,
  select,
  insert,
  update,
  delete,
  set,
  values,
  returning,
  eq,
  where_,
  orderBy,
  limit,
  toSql,
  getDecoder,
  getSql,
  getParams,
  getQueryType,
  hasReturning
)

{-| Query builder for type-safe SQL construction.

Build queries using composable functions instead of raw SQL strings.

Example:
```
users : Table
users = table "users"

users_id : Column Int
users_id = column users "id"

users_name : Column String
users_name = column users "name"
```
-}

import Lune.Prelude exposing (String, Int, Bool(..), List(..), Maybe(..), Unit, unit, Result(..))
import Lune.Database exposing (DbValue)
import Lune.Database.Decode exposing (Decoder)
import Lune.String as Str
import Lune.Int as Int

-- | Decoder that always succeeds with Unit
unitDecoder : Decoder Unit
unitDecoder = \_ -> Ok unit

-- | A database table reference
type alias Table = { name : String }

-- | A column reference with phantom type for the column's Lune type
type alias Column a = { tableName : String, columnName : String }

-- | Sort order for ORDER BY
type Order = Asc | Desc

-- | A WHERE condition (opaque, built with eq, gt, lt, etc.)
type alias Condition = { sql : String, params : List DbValue }

-- | Query type discriminator
type QueryType = Select | Insert | Update | Delete

-- | A column assignment for INSERT/UPDATE
type alias Assignment = { column : String, value : DbValue }

-- | A query that returns values of type 'a'
type alias Query a =
  { tableName : String
  , decoder : Decoder a
  , queryType : QueryType
  , conditions : List Condition
  , assignments : List Assignment
  , orderBy : Maybe { column : String, order : Order }
  , limitCount : Maybe Int
  , returningFlag : Bool
  }

-- | Create a table reference
table : String -> Table
table name = { name = name }

-- | Create a column reference
column : Table -> String -> Column a
column tbl colName = { tableName = tbl.name, columnName = colName }

-- | Start a SELECT query for a table
select : Table -> Decoder a -> Query a
select tbl decoder =
  { tableName = tbl.name
  , decoder = decoder
  , queryType = Select
  , conditions = Nil
  , assignments = Nil
  , orderBy = Nothing
  , limitCount = Nothing
  , returningFlag = False
  }

-- | Start an INSERT query for a table
insert : Table -> Decoder a -> Query a
insert tbl decoder =
  { tableName = tbl.name
  , decoder = decoder
  , queryType = Insert
  , conditions = Nil
  , assignments = Nil
  , orderBy = Nothing
  , limitCount = Nothing
  , returningFlag = False
  }

-- | Start an UPDATE query for a table
update : Table -> Decoder a -> Query a
update tbl decoder =
  { tableName = tbl.name
  , decoder = decoder
  , queryType = Update
  , conditions = Nil
  , assignments = Nil
  , orderBy = Nothing
  , limitCount = Nothing
  , returningFlag = False
  }

-- | Start a DELETE query for a table
delete : Table -> Query Unit
delete tbl =
  { tableName = tbl.name
  , decoder = unitDecoder
  , queryType = Delete
  , conditions = Nil
  , assignments = Nil
  , orderBy = Nothing
  , limitCount = Nothing
  , returningFlag = False
  }

-- | Create a column assignment
set : Column a -> DbValue -> Assignment
set col val = { column = col.columnName, value = val }

-- | Add column assignments to an INSERT query
values : List Assignment -> Query a -> Query a
values assigns query =
  { tableName = query.tableName
  , decoder = query.decoder
  , queryType = query.queryType
  , conditions = query.conditions
  , assignments = appendList assigns query.assignments
  , orderBy = query.orderBy
  , limitCount = query.limitCount
  , returningFlag = query.returningFlag
  }

-- | Add RETURNING clause to INSERT/UPDATE query
returning : Query a -> Query a
returning query =
  { tableName = query.tableName
  , decoder = query.decoder
  , queryType = query.queryType
  , conditions = query.conditions
  , assignments = query.assignments
  , orderBy = query.orderBy
  , limitCount = query.limitCount
  , returningFlag = True
  }

-- | Create an equality condition: column = value
eq : Column a -> DbValue -> Condition
eq col val =
  { sql = col.columnName
  , params = Cons val Nil
  }

-- | Add a WHERE condition to a query
where_ : Condition -> Query a -> Query a
where_ cond query =
  { tableName = query.tableName
  , decoder = query.decoder
  , queryType = query.queryType
  , conditions = Cons cond query.conditions
  , assignments = query.assignments
  , orderBy = query.orderBy
  , limitCount = query.limitCount
  , returningFlag = query.returningFlag
  }

-- | Add ORDER BY clause to a query
orderBy : Column a -> Order -> Query b -> Query b
orderBy col ord query =
  { tableName = query.tableName
  , decoder = query.decoder
  , queryType = query.queryType
  , conditions = query.conditions
  , assignments = query.assignments
  , orderBy = Just { column = col.columnName, order = ord }
  , limitCount = query.limitCount
  , returningFlag = query.returningFlag
  }

-- | Add LIMIT clause to a query
limit : Int -> Query a -> Query a
limit n query =
  { tableName = query.tableName
  , decoder = query.decoder
  , queryType = query.queryType
  , conditions = query.conditions
  , assignments = query.assignments
  , orderBy = query.orderBy
  , limitCount = Just n
  , returningFlag = query.returningFlag
  }

-- | Generate SQL and parameters from a query
toSql : Query a -> { sql : String, params : List DbValue }
toSql query =
  buildSqlResult query.tableName (buildWhere query.conditions 1) query.orderBy query.limitCount

-- | Helper to construct the final SQL result
buildSqlResult : String -> { sql : String, params : List DbValue } -> Maybe { column : String, order : Order } -> Maybe Int -> { sql : String, params : List DbValue }
buildSqlResult tableName whereResult maybeOrder maybeLimit =
  { sql = Str.append "SELECT * FROM "
      (Str.append tableName
        (Str.append whereResult.sql
          (Str.append (buildOrderBy maybeOrder) (buildLimit maybeLimit))))
  , params = whereResult.params
  }

-- | Build WHERE clause from conditions
-- Conditions are reversed (newest first), so we reverse them for correct SQL order
buildWhere : List Condition -> Int -> { sql : String, params : List DbValue }
buildWhere conds paramNum =
  case conds of
    Nil -> { sql = "", params = Nil }
    Cons _ _ -> buildWhereNonEmpty (reverseList conds) paramNum

-- | Build WHERE for non-empty condition list
buildWhereNonEmpty : List Condition -> Int -> { sql : String, params : List DbValue }
buildWhereNonEmpty conds paramNum =
  case buildClauses conds paramNum of
    result -> { sql = Str.append " WHERE " result.sql, params = result.params }

-- | Build clause fragments for all conditions
buildClauses : List Condition -> Int -> { sql : String, params : List DbValue }
buildClauses conds paramNum =
  case conds of
    Nil -> { sql = "", params = Nil }
    Cons cond Nil ->
      { sql = Str.append cond.sql (Str.append " = $" (Str.fromInt paramNum))
      , params = cond.params
      }
    Cons cond rest ->
      buildClauseWithRest cond rest paramNum

-- | Build clause with remaining conditions
buildClauseWithRest : Condition -> List Condition -> Int -> { sql : String, params : List DbValue }
buildClauseWithRest cond rest paramNum =
  case buildClauses rest (Int.add paramNum 1) of
    restResult ->
      { sql = Str.append cond.sql
          (Str.append " = $"
            (Str.append (Str.fromInt paramNum)
              (Str.append " AND " restResult.sql)))
      , params = appendList cond.params restResult.params
      }

-- | Reverse a list
reverseList : List a -> List a
reverseList xs = reverseHelper xs Nil

reverseHelper : List a -> List a -> List a
reverseHelper xs acc =
  case xs of
    Nil -> acc
    Cons x rest -> reverseHelper rest (Cons x acc)

-- | Build ORDER BY clause
buildOrderBy : Maybe { column : String, order : Order } -> String
buildOrderBy maybeOrder =
  case maybeOrder of
    Nothing -> ""
    Just ord ->
      Str.append " ORDER BY "
        (Str.append ord.column
          (case ord.order of
            Asc -> " ASC"
            Desc -> " DESC"))

-- | Build LIMIT clause
buildLimit : Maybe Int -> String
buildLimit maybeLimit =
  case maybeLimit of
    Nothing -> ""
    Just n -> Str.append " LIMIT " (Str.fromInt n)

-- | Append two lists
appendList : List a -> List a -> List a
appendList xs ys =
  case xs of
    Nil -> ys
    Cons x rest -> Cons x (appendList rest ys)

-- | Get list length
listLength : List a -> Int
listLength xs =
  case xs of
    Nil -> 0
    Cons _ rest -> Int.add 1 (listLength rest)

-- | Get the decoder from a query
getDecoder : Query a -> Decoder a
getDecoder q = q.decoder

-- | Get generated SQL from a query
getSql : Query a -> String
getSql q = (toSql q).sql

-- | Get parameters from a query
getParams : Query a -> List DbValue
getParams q = (toSql q).params

-- | Get the query type
getQueryType : Query a -> QueryType
getQueryType q = q.queryType

-- | Check if query has RETURNING clause
hasReturning : Query a -> Bool
hasReturning q = q.returningFlag
