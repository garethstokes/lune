module Lune.Database.Query exposing (
  Table,
  Field,
  Query,
  Order(..),
  QueryType(..),
  Condition,
  Assignment,
  table,
  field,
  select,
  insert,
  update,
  delete,
  set,
  values,
  returning,
  eq,
  gt,
  lt,
  gte,
  lte,
  neq,
  like,
  isNull,
  isNotNull,
  in_,
  where_,
  orderBy,
  limit,
  offset,
  toSql,
  getDecoder,
  getSql,
  getParams,
  getQueryType,
  hasReturning
)

{-| Query builder for type-safe SQL construction.

Build queries using composable functions instead of raw SQL strings.

Example:
```
users : Table
users = table "users"

users_id : Field Int
users_id = field users "id"

users_name : Field String
users_name = field users "name"
```
-}

import Lune.Prelude exposing (String, Int, Bool(..), List(..), Maybe(..), Unit, unit, Result(..))
import Lune.Database exposing (DbValue)
import Lune.Database.Decode exposing (Decoder)
import Lune.String as Str
import Lune.Int as Int

-- | Decoder that always succeeds with Unit
unitDecoder : Decoder Unit
unitDecoder = \_ -> Ok unit

-- | A database table reference
type alias Table = { name : String }

-- | A field reference with phantom type for the field's Lune type
-- Using a sum type with single constructor to preserve phantom type
type Field a = Field { tableName : String, fieldName : String }

-- | Sort order for ORDER BY
type Order = Asc | Desc

-- | A WHERE condition (opaque, built with eq, gt, lt, etc.)
type alias Condition = { sql : String, params : List DbValue }

-- | Query type discriminator
type QueryType = Select | Insert | Update | Delete

-- | A column assignment for INSERT/UPDATE
type alias Assignment = { column : String, value : DbValue }

-- | A query that returns values of type 'a'
type alias Query a =
  { tableName : String
  , decoder : Decoder a
  , queryType : QueryType
  , conditions : List Condition
  , assignments : List Assignment
  , orderBy : Maybe { column : String, order : Order }
  , limitCount : Maybe Int
  , offsetCount : Maybe Int
  , returningFlag : Bool
  }

-- | Create a table reference
table : String -> Table
table name = { name = name }

-- | Create a field reference
field : Table -> String -> Field a
field tbl fldName = Field { tableName = tbl.name, fieldName = fldName }

-- | Start a SELECT query for a table
select : Table -> Decoder a -> Query a
select tbl decoder =
  { tableName = tbl.name
  , decoder = decoder
  , queryType = Select
  , conditions = Nil
  , assignments = Nil
  , orderBy = Nothing
  , limitCount = Nothing
  , offsetCount = Nothing
  , returningFlag = False
  }

-- | Start an INSERT query for a table
insert : Table -> Decoder a -> Query a
insert tbl decoder =
  { tableName = tbl.name
  , decoder = decoder
  , queryType = Insert
  , conditions = Nil
  , assignments = Nil
  , orderBy = Nothing
  , limitCount = Nothing
  , offsetCount = Nothing
  , returningFlag = False
  }

-- | Start an UPDATE query for a table
update : Table -> Decoder a -> Query a
update tbl decoder =
  { tableName = tbl.name
  , decoder = decoder
  , queryType = Update
  , conditions = Nil
  , assignments = Nil
  , orderBy = Nothing
  , limitCount = Nothing
  , offsetCount = Nothing
  , returningFlag = False
  }

-- | Start a DELETE query for a table
delete : Table -> Query Unit
delete tbl =
  { tableName = tbl.name
  , decoder = unitDecoder
  , queryType = Delete
  , conditions = Nil
  , assignments = Nil
  , orderBy = Nothing
  , limitCount = Nothing
  , offsetCount = Nothing
  , returningFlag = False
  }

-- | Create a field assignment
set : Field a -> DbValue -> Assignment
set fld val =
  case fld of
    Field r -> { column = r.fieldName, value = val }

-- | Add column assignments to an INSERT query
values : List Assignment -> Query a -> Query a
values assigns query =
  { tableName = query.tableName
  , decoder = query.decoder
  , queryType = query.queryType
  , conditions = query.conditions
  , assignments = appendList assigns query.assignments
  , orderBy = query.orderBy
  , limitCount = query.limitCount
  , offsetCount = query.offsetCount
  , returningFlag = query.returningFlag
  }

-- | Add RETURNING clause to INSERT/UPDATE query
returning : Query a -> Query a
returning query =
  { tableName = query.tableName
  , decoder = query.decoder
  , queryType = query.queryType
  , conditions = query.conditions
  , assignments = query.assignments
  , orderBy = query.orderBy
  , limitCount = query.limitCount
  , offsetCount = query.offsetCount
  , returningFlag = True
  }

-- | Create an equality condition: field = value
eq : Field a -> DbValue -> Condition
eq fld val =
  case fld of
    Field r ->
      { sql = Str.append r.fieldName " ="
      , params = Cons val Nil
      }

-- | Create a greater-than condition: field > value
gt : Field a -> DbValue -> Condition
gt fld val =
  case fld of
    Field r ->
      { sql = Str.append r.fieldName " >"
      , params = Cons val Nil
      }

-- | Create a less-than condition: field < value
lt : Field a -> DbValue -> Condition
lt fld val =
  case fld of
    Field r ->
      { sql = Str.append r.fieldName " <"
      , params = Cons val Nil
      }

-- | Create a greater-than-or-equal condition: field >= value
gte : Field a -> DbValue -> Condition
gte fld val =
  case fld of
    Field r ->
      { sql = Str.append r.fieldName " >="
      , params = Cons val Nil
      }

-- | Create a less-than-or-equal condition: field <= value
lte : Field a -> DbValue -> Condition
lte fld val =
  case fld of
    Field r ->
      { sql = Str.append r.fieldName " <="
      , params = Cons val Nil
      }

-- | Create a not-equal condition: field <> value
neq : Field a -> DbValue -> Condition
neq fld val =
  case fld of
    Field r ->
      { sql = Str.append r.fieldName " <>"
      , params = Cons val Nil
      }

-- | Create a LIKE condition: field LIKE pattern
-- Use % for wildcards in the pattern string
like : Field String -> DbValue -> Condition
like fld val =
  case fld of
    Field r ->
      { sql = Str.append r.fieldName " LIKE"
      , params = Cons val Nil
      }

-- | Create an IS NULL condition: field IS NULL
isNull : Field a -> Condition
isNull fld =
  case fld of
    Field r ->
      { sql = Str.append r.fieldName " IS NULL"
      , params = Nil
      }

-- | Create an IS NOT NULL condition: field IS NOT NULL
isNotNull : Field a -> Condition
isNotNull fld =
  case fld of
    Field r ->
      { sql = Str.append r.fieldName " IS NOT NULL"
      , params = Nil
      }

-- | Create an IN condition: field IN (values...)
in_ : Field a -> List DbValue -> Condition
in_ fld vals =
  case fld of
    Field r ->
      { sql = Str.append r.fieldName " IN"
      , params = vals
      }

-- | Add a WHERE condition to a query
where_ : Condition -> Query a -> Query a
where_ cond query =
  { tableName = query.tableName
  , decoder = query.decoder
  , queryType = query.queryType
  , conditions = Cons cond query.conditions
  , assignments = query.assignments
  , orderBy = query.orderBy
  , limitCount = query.limitCount
  , offsetCount = query.offsetCount
  , returningFlag = query.returningFlag
  }

-- | Add ORDER BY clause to a query
orderBy : Field a -> Order -> Query b -> Query b
orderBy fld ord query =
  case fld of
    Field r ->
      { tableName = query.tableName
      , decoder = query.decoder
      , queryType = query.queryType
      , conditions = query.conditions
      , assignments = query.assignments
      , orderBy = Just { column = r.fieldName, order = ord }
      , limitCount = query.limitCount
      , offsetCount = query.offsetCount
      , returningFlag = query.returningFlag
      }

-- | Add LIMIT clause to a query
limit : Int -> Query a -> Query a
limit n query =
  { tableName = query.tableName
  , decoder = query.decoder
  , queryType = query.queryType
  , conditions = query.conditions
  , assignments = query.assignments
  , orderBy = query.orderBy
  , limitCount = Just n
  , offsetCount = query.offsetCount
  , returningFlag = query.returningFlag
  }

-- | Add OFFSET clause to a query (for pagination)
offset : Int -> Query a -> Query a
offset n query =
  { tableName = query.tableName
  , decoder = query.decoder
  , queryType = query.queryType
  , conditions = query.conditions
  , assignments = query.assignments
  , orderBy = query.orderBy
  , limitCount = query.limitCount
  , offsetCount = Just n
  , returningFlag = query.returningFlag
  }

-- | Generate SQL and parameters from a query
toSql : Query a -> { sql : String, params : List DbValue }
toSql query =
  case query.queryType of
    Select -> buildSelectSql query
    Insert -> buildInsertSql query
    Update -> buildUpdateSql query
    Delete -> buildDeleteSql query

-- | Build SELECT SQL
buildSelectSql : Query a -> { sql : String, params : List DbValue }
buildSelectSql query =
  buildSelectSqlResult query.tableName (buildWhere query.conditions 1) query.orderBy query.limitCount query.offsetCount

-- | Helper to construct the final SELECT SQL result
buildSelectSqlResult : String -> { sql : String, params : List DbValue } -> Maybe { column : String, order : Order } -> Maybe Int -> Maybe Int -> { sql : String, params : List DbValue }
buildSelectSqlResult tableName whereResult maybeOrder maybeLimit maybeOffset =
  { sql = Str.append "SELECT * FROM "
      (Str.append tableName
        (Str.append whereResult.sql
          (Str.append (buildOrderBy maybeOrder)
            (Str.append (buildLimit maybeLimit) (buildOffset maybeOffset)))))
  , params = whereResult.params
  }

-- | Build INSERT SQL
buildInsertSql : Query a -> { sql : String, params : List DbValue }
buildInsertSql query =
  case query.assignments of
    Nil -> { sql = Str.append "INSERT INTO " (Str.append query.tableName " DEFAULT VALUES"), params = Nil }
    _ -> buildInsertWithValues query

-- | Build INSERT with values
buildInsertWithValues : Query a -> { sql : String, params : List DbValue }
buildInsertWithValues query =
  { sql = Str.append "INSERT INTO "
      (Str.append query.tableName
        (Str.append " ("
          (Str.append (buildColumnList query.assignments)
            (Str.append ") VALUES ("
              (Str.append (buildPlaceholders query.assignments 1)
                (Str.append ")" (buildReturning query.returningFlag)))))))
  , params = collectAssignmentValues query.assignments
  }

-- | Build comma-separated column names
buildColumnList : List Assignment -> String
buildColumnList assigns =
  case assigns of
    Nil -> ""
    Cons a Nil -> a.column
    Cons a rest -> Str.append a.column (Str.append ", " (buildColumnList rest))

-- | Build comma-separated placeholders ($1, $2, ...)
buildPlaceholders : List Assignment -> Int -> String
buildPlaceholders assigns n =
  case assigns of
    Nil -> ""
    Cons _ Nil -> Str.append "$" (Str.fromInt n)
    Cons _ rest -> Str.append "$" (Str.append (Str.fromInt n) (Str.append ", " (buildPlaceholders rest (Int.add n 1))))

-- | Collect values from assignments
collectAssignmentValues : List Assignment -> List DbValue
collectAssignmentValues assigns =
  case assigns of
    Nil -> Nil
    Cons a rest -> Cons a.value (collectAssignmentValues rest)

-- | Build RETURNING clause
buildReturning : Bool -> String
buildReturning flag =
  case flag of
    True -> " RETURNING *"
    False -> ""

-- | Build UPDATE SQL
buildUpdateSql : Query a -> { sql : String, params : List DbValue }
buildUpdateSql query =
  case query.assignments of
    Nil -> { sql = Str.append "UPDATE " (Str.append query.tableName " SET "), params = Nil }
    _ -> buildUpdateWithSets query

-- | Build UPDATE with SET clauses
buildUpdateWithSets : Query a -> { sql : String, params : List DbValue }
buildUpdateWithSets query =
  buildUpdateResult query.tableName query.assignments query.conditions query.returningFlag

-- | Build UPDATE result with proper parameter numbering
buildUpdateResult : String -> List Assignment -> List Condition -> Bool -> { sql : String, params : List DbValue }
buildUpdateResult tableName assigns conds retFlag =
  case buildSetClauses assigns 1 of
    setResult ->
      case buildWhere conds (Int.add 1 (listLength assigns)) of
        whereResult ->
          { sql = Str.append "UPDATE "
              (Str.append tableName
                (Str.append " SET "
                  (Str.append setResult.sql
                    (Str.append whereResult.sql (buildReturning retFlag)))))
          , params = appendList setResult.params whereResult.params
          }

-- | Build SET clauses (col1 = $1, col2 = $2, ...)
buildSetClauses : List Assignment -> Int -> { sql : String, params : List DbValue }
buildSetClauses assigns n =
  case assigns of
    Nil -> { sql = "", params = Nil }
    Cons a Nil ->
      { sql = Str.append a.column (Str.append " = $" (Str.fromInt n))
      , params = Cons a.value Nil
      }
    Cons a rest ->
      case buildSetClauses rest (Int.add n 1) of
        restResult ->
          { sql = Str.append a.column
              (Str.append " = $"
                (Str.append (Str.fromInt n)
                  (Str.append ", " restResult.sql)))
          , params = Cons a.value restResult.params
          }

-- | Build DELETE SQL
buildDeleteSql : Query a -> { sql : String, params : List DbValue }
buildDeleteSql query =
  case buildWhere query.conditions 1 of
    whereResult ->
      { sql = Str.append "DELETE FROM " (Str.append query.tableName whereResult.sql)
      , params = whereResult.params
      }

-- | Build WHERE clause from conditions
-- Conditions are reversed (newest first), so we reverse them for correct SQL order
buildWhere : List Condition -> Int -> { sql : String, params : List DbValue }
buildWhere conds paramNum =
  case conds of
    Nil -> { sql = "", params = Nil }
    Cons _ _ -> buildWhereNonEmpty (reverseList conds) paramNum

-- | Build WHERE for non-empty condition list
buildWhereNonEmpty : List Condition -> Int -> { sql : String, params : List DbValue }
buildWhereNonEmpty conds paramNum =
  case buildClauses conds paramNum of
    result -> { sql = Str.append " WHERE " result.sql, params = result.params }

-- | Build clause fragments for all conditions
buildClauses : List Condition -> Int -> { sql : String, params : List DbValue }
buildClauses conds paramNum =
  case conds of
    Nil -> { sql = "", params = Nil }
    Cons cond Nil ->
      buildSingleClause cond paramNum
    Cons cond rest ->
      buildClauseWithRest cond rest paramNum

-- | Build a single clause, handling parameterless and multi-param conditions
buildSingleClause : Condition -> Int -> { sql : String, params : List DbValue }
buildSingleClause cond paramNum =
  case cond.params of
    Nil -> { sql = cond.sql, params = Nil }
    Cons _ Nil -> { sql = Str.append cond.sql (Str.append " $" (Str.fromInt paramNum)), params = cond.params }
    Cons _ (Cons _ _) -> buildInClause cond paramNum

-- | Build IN clause with multiple placeholders
buildInClause : Condition -> Int -> { sql : String, params : List DbValue }
buildInClause cond paramNum =
  { sql = Str.append cond.sql (Str.append " (" (Str.append (buildInPlaceholders cond.params paramNum) ")"))
  , params = cond.params
  }

-- | Build comma-separated placeholders for IN clause
buildInPlaceholders : List DbValue -> Int -> String
buildInPlaceholders vals n =
  case vals of
    Nil -> ""
    Cons _ Nil -> Str.append "$" (Str.fromInt n)
    Cons _ rest -> Str.append "$" (Str.append (Str.fromInt n) (Str.append ", " (buildInPlaceholders rest (Int.add n 1))))

-- | Build clause with remaining conditions
buildClauseWithRest : Condition -> List Condition -> Int -> { sql : String, params : List DbValue }
buildClauseWithRest cond rest paramNum =
  case cond.params of
    Nil ->
      case buildClauses rest paramNum of
        restResult ->
          { sql = Str.append cond.sql (Str.append " AND " restResult.sql)
          , params = restResult.params
          }
    _ ->
      case buildClauses rest (Int.add paramNum (listLength cond.params)) of
        restResult ->
          case cond.params of
            Cons _ Nil ->
              { sql = Str.append cond.sql
                  (Str.append " $"
                    (Str.append (Str.fromInt paramNum)
                      (Str.append " AND " restResult.sql)))
              , params = appendList cond.params restResult.params
              }
            _ ->
              { sql = Str.append cond.sql
                  (Str.append " ("
                    (Str.append (buildInPlaceholders cond.params paramNum)
                      (Str.append ") AND " restResult.sql)))
              , params = appendList cond.params restResult.params
              }

-- | Reverse a list
reverseList : List a -> List a
reverseList xs = reverseHelper xs Nil

reverseHelper : List a -> List a -> List a
reverseHelper xs acc =
  case xs of
    Nil -> acc
    Cons x rest -> reverseHelper rest (Cons x acc)

-- | Build ORDER BY clause
buildOrderBy : Maybe { column : String, order : Order } -> String
buildOrderBy maybeOrder =
  case maybeOrder of
    Nothing -> ""
    Just ord ->
      Str.append " ORDER BY "
        (Str.append ord.column
          (case ord.order of
            Asc -> " ASC"
            Desc -> " DESC"))

-- | Build LIMIT clause
buildLimit : Maybe Int -> String
buildLimit maybeLimit =
  case maybeLimit of
    Nothing -> ""
    Just n -> Str.append " LIMIT " (Str.fromInt n)

-- | Build OFFSET clause
buildOffset : Maybe Int -> String
buildOffset maybeOffset =
  case maybeOffset of
    Nothing -> ""
    Just n -> Str.append " OFFSET " (Str.fromInt n)

-- | Append two lists
appendList : List a -> List a -> List a
appendList xs ys =
  case xs of
    Nil -> ys
    Cons x rest -> Cons x (appendList rest ys)

-- | Get list length
listLength : List a -> Int
listLength xs =
  case xs of
    Nil -> 0
    Cons _ rest -> Int.add 1 (listLength rest)

-- | Get the decoder from a query
getDecoder : Query a -> Decoder a
getDecoder q = q.decoder

-- | Get generated SQL from a query
getSql : Query a -> String
getSql q = (toSql q).sql

-- | Get parameters from a query
getParams : Query a -> List DbValue
getParams q = (toSql q).params

-- | Get the query type
getQueryType : Query a -> QueryType
getQueryType q = q.queryType

-- | Check if query has RETURNING clause
hasReturning : Query a -> Bool
hasReturning q = q.returningFlag
