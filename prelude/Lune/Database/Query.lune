module Lune.Database.Query exposing (
  Table,
  Column,
  Query,
  Order(..),
  Condition,
  table,
  column,
  select,
  eq,
  where_,
  orderBy,
  limit,
  toSql,
  getDecoder,
  getSql,
  getParams
)

{-| Query builder for type-safe SQL construction.

Build queries using composable functions instead of raw SQL strings.

Example:
```
users : Table
users = table "users"

users_id : Column Int
users_id = column users "id"

users_name : Column String
users_name = column users "name"
```
-}

import Lune.Prelude exposing (String, Int, List(..), Maybe(..))
import Lune.Database exposing (DbValue)
import Lune.Database.Decode exposing (Decoder)
import Lune.String as Str
import Lune.Int as Int

-- | A database table reference
type alias Table = { name : String }

-- | A column reference with phantom type for the column's Lune type
type alias Column a = { tableName : String, columnName : String }

-- | Sort order for ORDER BY
type Order = Asc | Desc

-- | A WHERE condition (opaque, built with eq, gt, lt, etc.)
type alias Condition = { sql : String, params : List DbValue }

-- | A query that returns values of type 'a'
type alias Query a =
  { tableName : String
  , decoder : Decoder a
  , conditions : List Condition
  , orderBy : Maybe { column : String, order : Order }
  , limitCount : Maybe Int
  }

-- | Create a table reference
table : String -> Table
table name = { name = name }

-- | Create a column reference
column : Table -> String -> Column a
column tbl colName = { tableName = tbl.name, columnName = colName }

-- | Start a SELECT query for a table
select : Table -> Decoder a -> Query a
select tbl decoder =
  { tableName = tbl.name
  , decoder = decoder
  , conditions = Nil
  , orderBy = Nothing
  , limitCount = Nothing
  }

-- | Create an equality condition: column = value
eq : Column a -> DbValue -> Condition
eq col val =
  { sql = col.columnName
  , params = Cons val Nil
  }

-- | Add a WHERE condition to a query
where_ : Condition -> Query a -> Query a
where_ cond query =
  { tableName = query.tableName
  , decoder = query.decoder
  , conditions = Cons cond query.conditions
  , orderBy = query.orderBy
  , limitCount = query.limitCount
  }

-- | Add ORDER BY clause to a query
orderBy : Column a -> Order -> Query b -> Query b
orderBy col ord query =
  { tableName = query.tableName
  , decoder = query.decoder
  , conditions = query.conditions
  , orderBy = Just { column = col.columnName, order = ord }
  , limitCount = query.limitCount
  }

-- | Add LIMIT clause to a query
limit : Int -> Query a -> Query a
limit n query =
  { tableName = query.tableName
  , decoder = query.decoder
  , conditions = query.conditions
  , orderBy = query.orderBy
  , limitCount = Just n
  }

-- | Generate SQL and parameters from a query
toSql : Query a -> { sql : String, params : List DbValue }
toSql query =
  buildSqlResult query.tableName (buildWhere query.conditions 1) query.orderBy query.limitCount

-- | Helper to construct the final SQL result
buildSqlResult : String -> { sql : String, params : List DbValue } -> Maybe { column : String, order : Order } -> Maybe Int -> { sql : String, params : List DbValue }
buildSqlResult tableName whereResult maybeOrder maybeLimit =
  { sql = Str.append "SELECT * FROM "
      (Str.append tableName
        (Str.append whereResult.sql
          (Str.append (buildOrderBy maybeOrder) (buildLimit maybeLimit))))
  , params = whereResult.params
  }

-- | Build WHERE clause from conditions
buildWhere : List Condition -> Int -> { sql : String, params : List DbValue }
buildWhere conds paramNum =
  case conds of
    Nil -> { sql = "", params = Nil }
    Cons cond Nil ->
      { sql = Str.append " WHERE "
          (Str.append cond.sql
            (Str.append " = $" (Str.fromInt paramNum)))
      , params = cond.params
      }
    Cons cond rest ->
      combineConditions cond rest paramNum

-- | Helper to combine multiple conditions with AND
combineConditions : Condition -> List Condition -> Int -> { sql : String, params : List DbValue }
combineConditions cond rest paramNum =
  { sql = Str.append (buildWhere rest paramNum).sql
      (Str.append " AND "
        (Str.append cond.sql
          (Str.append " = $" (Str.fromInt (Int.add paramNum (listLength cond.params))))))
  , params = appendList (buildWhere rest paramNum).params cond.params
  }

-- | Build ORDER BY clause
buildOrderBy : Maybe { column : String, order : Order } -> String
buildOrderBy maybeOrder =
  case maybeOrder of
    Nothing -> ""
    Just ord ->
      Str.append " ORDER BY "
        (Str.append ord.column
          (case ord.order of
            Asc -> " ASC"
            Desc -> " DESC"))

-- | Build LIMIT clause
buildLimit : Maybe Int -> String
buildLimit maybeLimit =
  case maybeLimit of
    Nothing -> ""
    Just n -> Str.append " LIMIT " (Str.fromInt n)

-- | Append two lists
appendList : List a -> List a -> List a
appendList xs ys =
  case xs of
    Nil -> ys
    Cons x rest -> Cons x (appendList rest ys)

-- | Get list length
listLength : List a -> Int
listLength xs =
  case xs of
    Nil -> 0
    Cons _ rest -> Int.add 1 (listLength rest)

-- | Get the decoder from a query
getDecoder : Query a -> Decoder a
getDecoder q = q.decoder

-- | Get generated SQL from a query
getSql : Query a -> String
getSql q = (toSql q).sql

-- | Get parameters from a query
getParams : Query a -> List DbValue
getParams q = (toSql q).params
