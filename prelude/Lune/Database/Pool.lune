module Lune.Database.Pool exposing (
  Pool,
  ConnectionOps,
  createPool,
  destroyPool,
  withConnection
)

{-| Generic STM-based connection pool.

Works with any database connection type by taking connection operations
as parameters. Each database backend can have its own error type.

Manages a pool of reusable connections with configurable maximum size.
Uses STM (Atomic) for thread-safe acquire/release without locks.

When all connections are in use, `withConnection` blocks (via STM retry)
until one is released by another fiber.

Example:
```
let ops =
  { open = \() -> PgConn.connect "localhost" 5432 "mydb" "user"
  , close = PgConn.close
  }
pool <- Pool.createPool 10 ops
result <- Pool.withConnection pool (\conn ->
  Query.execute conn "SELECT 1"
)
Pool.destroyPool pool
```
-}

import Lune.Prelude exposing (IO, Result(..), Unit, List(..), Int, Bool(..), Monad(..))
import Lune.Atomic as Atomic exposing (Atomic, Shared)
import Lune.Int as Int
import Lune.Task as Task exposing (Task)
import Lune.IO as LuneIO

-- | Operations required for managing connections
-- `open` creates a new connection
-- `close` closes a connection
type alias ConnectionOps conn err =
  { open : Unit -> Task err conn
  , close : conn -> Task err Unit
  }

-- | Generic connection pool
-- Holds idle connections, tracks in-use count, and stores connection operations
type alias Pool conn err =
  { maxConnections : Int
  , idle : Shared (List conn)
  , inUse : Shared Int
  , closed : Shared Bool
  , ops : ConnectionOps conn err
  }

-- | Create a new connection pool
-- No connections are opened eagerly; they are created on demand up to maxConnections.
createPool : Int -> ConnectionOps conn err -> IO (Pool conn err)
createPool maxConns ops =
  do
    idleVar <- Atomic.commit (Atomic.new Nil)
    inUseVar <- Atomic.commit (Atomic.new 0)
    closedVar <- Atomic.commit (Atomic.new False)
    pure
      { maxConnections = maxConns
      , idle = idleVar
      , inUse = inUseVar
      , closed = closedVar
      , ops = ops
      }

-- | Destroy the pool, closing all idle connections
destroyPool : Pool conn err -> IO Unit
destroyPool pool =
  do
    conns <- Atomic.commit
      (do
        Atomic.write pool.closed True
        idleConns <- Atomic.read pool.idle
        Atomic.write pool.idle Nil
        pure idleConns
      )
    closeAll pool.ops.close conns

closeAll : (conn -> Task err Unit) -> List conn -> IO Unit
closeAll closeFn conns =
  case conns of
    Nil -> LuneIO.pure Unit
    Cons c rest ->
      do
        _ <- Task.attempt (closeFn c)
        closeAll closeFn rest

-- | Use a connection from the pool, automatically releasing it when done
-- If an error occurs during the action, the connection is still returned to the pool.
withConnection : Pool conn err -> (conn -> Task err a) -> Task err a
withConnection pool action =
  Task
    ( do
        acquireResultIO <- Task.attempt (acquire pool)
        case acquireResultIO of
          Err e -> LuneIO.pure (Err e)
          Ok conn ->
            do
              resultIO <- Task.attempt (action conn)
              _ <- Task.attempt (releaseTask pool conn)
              LuneIO.pure resultIO
    )

releaseTask : Pool conn err -> conn -> Task x Unit
releaseTask pool conn =
  Task.fromIO (release pool conn)

-- Internal: acquire a connection from the pool
acquire : Pool conn err -> Task err conn
acquire pool =
  Task
    ( do
        outcome <- Atomic.commit (tryAcquire pool)
        Task.attempt (handleAcquireOutcome pool outcome)
    )

-- STM transaction: try to take an idle connection or reserve a slot for a new one
-- Returns: Ok (Just conn) if we got an idle connection
--          Ok Nothing if we reserved a slot and should open a new connection
--          Retries (waits) if at max capacity with no idle connections
tryAcquire : Pool conn err -> Atomic (Maybe conn)
tryAcquire pool =
  do
    isClosed <- Atomic.read pool.closed
    case isClosed of
      True -> Atomic.wait  -- Pool is closed, wait indefinitely (will never succeed)
      False ->
        do
          idleConns <- Atomic.read pool.idle
          case idleConns of
            Cons conn rest ->
              do
                Atomic.write pool.idle rest
                used <- Atomic.read pool.inUse
                Atomic.write pool.inUse (Int.add used 1)
                pure (Just conn)
            Nil ->
              do
                used <- Atomic.read pool.inUse
                case Int.lt used pool.maxConnections of
                  True ->
                    do
                      Atomic.write pool.inUse (Int.add used 1)
                      pure Nothing
                  False ->
                    Atomic.wait

handleAcquireOutcome : Pool conn err -> Maybe conn -> Task err conn
handleAcquireOutcome pool outcome =
  case outcome of
    Just conn -> Task.succeed conn
    Nothing -> openNewConnection pool

-- Internal: open a new connection using the pool's ops
openNewConnection : Pool conn err -> Task err conn
openNewConnection pool =
  Task.onError (pool.ops.open Unit)
    (\e ->
      Task
        ( do
            Atomic.commit
              (do
                used <- Atomic.read pool.inUse
                Atomic.write pool.inUse (Int.sub used 1)
              )
            LuneIO.pure (Err e)
        )
    )

-- Internal: release a connection back to the pool
release : Pool conn err -> conn -> IO Unit
release pool conn =
  Atomic.commit
    (do
      isClosed <- Atomic.read pool.closed
      case isClosed of
        True -> pure Unit
        False ->
          do
            idleConns <- Atomic.read pool.idle
            Atomic.write pool.idle (Cons conn idleConns)
            used <- Atomic.read pool.inUse
            Atomic.write pool.inUse (Int.sub used 1)
            pure Unit
    )
