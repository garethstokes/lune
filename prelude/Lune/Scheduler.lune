module Lune.Scheduler exposing (
  Scheduler,
  JobId(..),
  Schedule(..),
  Concurrency(..),
  JobSpec,
  SchedulerError(..),
  new,
  start,
  stop,
  register,
  unregister,
  trigger
)

{-| Job scheduling for Lune.

Provides cron-like scheduling using fibers and STM.
Jobs can run on intervals, after delays, or be triggered manually.

Example:
```
main =
  do
    sched <- Scheduler.new
    _ <- Scheduler.register sched
      { id = JobId "tick"
      , schedule = EveryMs 1000
      , concurrency = OneInstance
      , action = IO.println "tick"
      }
    _ <- Scheduler.start sched
    _ <- IO.sleepMs 5000
    Scheduler.stop sched
```
-}

import Lune.Prelude exposing (
  Bool(..), Int, List(..), Maybe(..), Result(..), Task(..), Unit, unit, Applicative(..), Monad(..)
)
import Lune.Atomic as Atomic exposing (Atomic, Shared)
import Lune.Fiber as Fiber exposing (Fiber)
import Lune.Task as Task
import Lune.IO as IO
import Lune.Int as Int
import Lune.String as String

-- =============================================================================
-- Public Types
-- =============================================================================

-- | Unique identifier for a job
type JobId = JobId String

-- | When a job should run
type Schedule =
  Manual
  | AfterMs Int
  | EveryMs Int

-- | How concurrent triggers are handled
type Concurrency =
  OneInstance
  | AllowConcurrent

-- | Job specification
type alias JobSpec =
  { id : JobId
  , schedule : Schedule
  , concurrency : Concurrency
  , action : Task Unit Unit
  }

-- | Scheduler errors
type SchedulerError =
  JobAlreadyRegistered
  | JobNotFound
  | SchedulerNotRunning

-- | The scheduler handle (opaque to users)
type alias Scheduler =
  { state : SchedulerState
  }

-- =============================================================================
-- Internal Types
-- =============================================================================

-- Internal state held in STM
type alias SchedulerState =
  { running : Shared Bool
  , jobs : Shared (List JobEntry)
  , queue : Shared (List JobId)
  , inFlight : Shared (List JobId)
  }

-- Job entry with metadata
type alias JobEntry =
  { spec : JobSpec
  , timerFiber : Maybe (Fiber (Result Unit Unit))
  }

-- =============================================================================
-- Lifecycle
-- =============================================================================

-- | Create a new scheduler (not yet running)
new : Task e Scheduler
new =
  do
    runningVar <- Atomic.commit (Atomic.new False)
    jobsVar <- Atomic.commit (Atomic.new Nil)
    queueVar <- Atomic.commit (Atomic.new Nil)
    inFlightVar <- Atomic.commit (Atomic.new Nil)
    Task.succeed
      { state =
        { running = runningVar
        , jobs = jobsVar
        , queue = queueVar
        , inFlight = inFlightVar
        }
      }

-- | Start the scheduler (spawns the runner fiber)
start : Scheduler -> Task e Unit
start sched =
  do
    _ <- Atomic.commit (Atomic.write sched.state.running True)
    _ <- Fiber.spawn (runnerLoop sched)
    Task.succeed unit

-- | Stop the scheduler (runner will exit on next iteration)
stop : Scheduler -> Task e Unit
stop sched =
  Atomic.commit (Atomic.write sched.state.running False)

-- =============================================================================
-- Internal Helpers
-- =============================================================================

-- | Check if a JobId matches
jobIdEq : JobId -> JobId -> Bool
jobIdEq a b =
  case a of
    JobId sa ->
      case b of
        JobId sb -> String.eq sa sb

-- | Find a job entry by ID
findJob : JobId -> List JobEntry -> Maybe JobEntry
findJob targetId entries =
  case entries of
    Nil -> Nothing
    Cons entry rest ->
      case jobIdEq targetId entry.spec.id of
        True -> Just entry
        False -> findJob targetId rest

-- | Check if a JobId is in a list
memberJobId : JobId -> List JobId -> Bool
memberJobId targetId ids =
  case ids of
    Nil -> False
    Cons id rest ->
      case jobIdEq targetId id of
        True -> True
        False -> memberJobId targetId rest

-- | Remove a job entry by ID
removeJob : JobId -> List JobEntry -> List JobEntry
removeJob targetId entries =
  case entries of
    Nil -> Nil
    Cons entry rest ->
      case jobIdEq targetId entry.spec.id of
        True -> rest
        False -> Cons entry (removeJob targetId rest)

-- | Remove a JobId from a list
removeJobId : JobId -> List JobId -> List JobId
removeJobId targetId ids =
  case ids of
    Nil -> Nil
    Cons id rest ->
      case jobIdEq targetId id of
        True -> rest
        False -> Cons id (removeJobId targetId rest)

-- =============================================================================
-- Job Management
-- =============================================================================

-- | Register a job with the scheduler
-- Returns Err if a job with the same ID already exists
register : Scheduler -> JobSpec -> Task SchedulerError Unit
register sched spec =
  do
    result <- Atomic.commit
      (do
        jobs <- Atomic.read sched.state.jobs
        case findJob spec.id jobs of
          Just existing -> pure (Err JobAlreadyRegistered)
          Nothing ->
            do
              let entry = { spec = spec, timerFiber = Nothing }
              Atomic.write sched.state.jobs (Cons entry jobs)
              pure (Ok unit)
      )
    case result of
      Err e -> Task.fail e
      Ok u ->
        do
          armSchedule sched spec

-- | Spawn a timer fiber for scheduled jobs
armSchedule : Scheduler -> JobSpec -> Task e Unit
armSchedule sched spec =
  case spec.schedule of
    Manual ->
      Task.succeed unit
    AfterMs delayMs ->
      do
        _ <- Fiber.spawn (afterMsTimer sched spec.id delayMs)
        Task.succeed unit
    EveryMs intervalMs ->
      do
        _ <- Fiber.spawn (everyMsTimer sched spec.id intervalMs)
        Task.succeed unit

-- | Timer for AfterMs: sleep then trigger once
afterMsTimer : Scheduler -> JobId -> Int -> Task Unit Unit
afterMsTimer sched jobId delayMs =
  do
    _ <- IO.sleepMs delayMs
    _ <- triggerInternal sched jobId
    -- Auto-unregister after running
    unregisterInternal sched jobId

-- | Timer for EveryMs: loop forever, sleep then trigger
everyMsTimer : Scheduler -> JobId -> Int -> Task Unit Unit
everyMsTimer sched jobId intervalMs =
  do
    isRunning <- Atomic.commit (Atomic.read sched.state.running)
    case isRunning of
      False -> Task.succeed unit
      True ->
        do
          _ <- IO.sleepMs intervalMs
          _ <- triggerInternal sched jobId
          everyMsTimer sched jobId intervalMs

-- | Unregister a job (removes it from the scheduler)
unregister : Scheduler -> JobId -> Task e Unit
unregister sched jobId =
  unregisterInternal sched jobId

-- | Internal unregister (doesn't fail if job not found)
unregisterInternal : Scheduler -> JobId -> Task e Unit
unregisterInternal sched jobId =
  do
    _ <- Atomic.commit
      (do
        jobs <- Atomic.read sched.state.jobs
        Atomic.write sched.state.jobs (removeJob jobId jobs)
      )
    _ <- Atomic.commit
      (do
        queue <- Atomic.read sched.state.queue
        Atomic.write sched.state.queue (removeJobId jobId queue)
      )
    _ <- Atomic.commit
      (do
        inFlight <- Atomic.read sched.state.inFlight
        Atomic.write sched.state.inFlight (removeJobId jobId inFlight)
      )
    Task.succeed unit

-- | Manually trigger a job to run
-- Returns Err if job doesn't exist or scheduler not running
trigger : Scheduler -> JobId -> Task SchedulerError Unit
trigger sched jobId =
  do
    isRunning <- Atomic.commit (Atomic.read sched.state.running)
    case isRunning of
      False -> Task.fail SchedulerNotRunning
      True ->
        do
          result <- Atomic.commit
            (do
              jobs <- Atomic.read sched.state.jobs
              case findJob jobId jobs of
                Nothing -> pure (Err JobNotFound)
                Just entry ->
                  do
                    queue <- Atomic.read sched.state.queue
                    Atomic.write sched.state.queue (Cons jobId queue)
                    pure (Ok unit)
            )
          case result of
            Err e -> Task.fail e
            Ok u -> Task.succeed unit

-- | Internal trigger (doesn't fail, used by timers)
triggerInternal : Scheduler -> JobId -> Task e Unit
triggerInternal sched jobId =
  do
    _ <- Atomic.commit
      (do
        queue <- Atomic.read sched.state.queue
        Atomic.write sched.state.queue (Cons jobId queue)
      )
    Task.succeed unit

-- =============================================================================
-- Runner
-- =============================================================================

-- | Main runner loop - processes jobs from the queue
runnerLoop : Scheduler -> Task Unit Unit
runnerLoop sched =
  do
    isRunning <- Atomic.commit (Atomic.read sched.state.running)
    case isRunning of
      False -> Task.succeed unit
      True ->
        do
          maybeJob <- Atomic.commit (tryDequeue sched)
          case maybeJob of
            Nothing ->
              do
                _ <- Fiber.yield
                runnerLoop sched
            Just entry ->
              do
                _ <- executeJob sched entry
                runnerLoop sched

-- | Try to dequeue a job, respecting concurrency policy
tryDequeue : Scheduler -> Atomic (Maybe JobEntry)
tryDequeue sched =
  do
    queue <- Atomic.read sched.state.queue
    case queue of
      Nil -> pure Nothing
      Cons jobId rest ->
        do
          Atomic.write sched.state.queue rest
          jobs <- Atomic.read sched.state.jobs
          case findJob jobId jobs of
            Nothing ->
              pure Nothing
            Just entry ->
              case entry.spec.concurrency of
                AllowConcurrent ->
                  pure (Just entry)
                OneInstance ->
                  do
                    inFlight <- Atomic.read sched.state.inFlight
                    case memberJobId jobId inFlight of
                      True ->
                        pure Nothing
                      False ->
                        do
                          Atomic.write sched.state.inFlight (Cons jobId inFlight)
                          pure (Just entry)

-- | Execute a job and clean up inFlight
executeJob : Scheduler -> JobEntry -> Task Unit Unit
executeJob sched entry =
  do
    _ <- Task.onError entry.spec.action (\err -> Task.succeed unit)
    case entry.spec.concurrency of
      AllowConcurrent ->
        Task.succeed unit
      OneInstance ->
        do
          _ <- Atomic.commit
            (do
              inFlight <- Atomic.read sched.state.inFlight
              Atomic.write sched.state.inFlight (removeJobId entry.spec.id inFlight)
            )
          Task.succeed unit
