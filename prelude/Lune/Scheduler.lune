module Lune.Scheduler exposing (
  Scheduler,
  JobId(..),
  Schedule(..),
  Concurrency(..),
  JobSpec,
  SchedulerError(..),
  new,
  start,
  stop,
  register,
  unregister,
  trigger
)

{-| Job scheduling for Lune.

Provides cron-like scheduling using fibers and STM.
Jobs can run on intervals, after delays, or be triggered manually.

Example:
```
main =
  do
    sched <- Scheduler.new
    _ <- Scheduler.register sched
      { id = JobId "tick"
      , schedule = EveryMs 1000
      , concurrency = OneInstance
      , action = IO.println "tick"
      }
    _ <- Scheduler.start sched
    _ <- IO.sleepMs 5000
    Scheduler.stop sched
```
-}

import Lune.Prelude exposing (
  Bool(..), Int, List(..), Maybe(..), Result(..), Task(..), Unit
)
import Lune.Atomic as Atomic exposing (Atomic, Shared)
import Lune.Fiber as Fiber exposing (Fiber)
import Lune.Task as Task
import Lune.IO as IO
import Lune.Int as Int
import Lune.String as String

-- =============================================================================
-- Public Types
-- =============================================================================

-- | Unique identifier for a job
type JobId = JobId String

-- | When a job should run
type Schedule =
  Manual
  | AfterMs Int
  | EveryMs Int

-- | How concurrent triggers are handled
type Concurrency =
  OneInstance
  | AllowConcurrent

-- | Job specification
type alias JobSpec =
  { id : JobId
  , schedule : Schedule
  , concurrency : Concurrency
  , action : Task Unit Unit
  }

-- | Scheduler errors
type SchedulerError =
  JobAlreadyRegistered
  | JobNotFound
  | SchedulerNotRunning

-- | The scheduler handle (opaque to users)
type alias Scheduler =
  { state : SchedulerState
  }

-- =============================================================================
-- Internal Types
-- =============================================================================

-- Internal state held in STM
type alias SchedulerState =
  { running : Shared Bool
  , jobs : Shared (List JobEntry)
  , queue : Shared (List JobId)
  , inFlight : Shared (List JobId)
  }

-- Job entry with metadata
type alias JobEntry =
  { spec : JobSpec
  , timerFiber : Maybe (Fiber (Result Unit Unit))
  }

-- =============================================================================
-- Lifecycle
-- =============================================================================

-- | Create a new scheduler (not yet running)
new : Task e Scheduler
new =
  do
    runningVar <- Atomic.commit (Atomic.new False)
    jobsVar <- Atomic.commit (Atomic.new Nil)
    queueVar <- Atomic.commit (Atomic.new Nil)
    inFlightVar <- Atomic.commit (Atomic.new Nil)
    Task.succeed
      { state =
        { running = runningVar
        , jobs = jobsVar
        , queue = queueVar
        , inFlight = inFlightVar
        }
      }

-- | Start the scheduler (spawns the runner fiber)
start : Scheduler -> Task e Unit
start sched =
  do
    _ <- Atomic.commit (Atomic.write sched.state.running True)
    _ <- Fiber.spawn (runnerLoop sched)
    Task.succeed Unit

-- | Stop the scheduler (runner will exit on next iteration)
stop : Scheduler -> Task e Unit
stop sched =
  Atomic.commit (Atomic.write sched.state.running False)

-- =============================================================================
-- Internal Helpers
-- =============================================================================

-- | Check if a JobId matches
jobIdEq : JobId -> JobId -> Bool
jobIdEq a b =
  case a of
    JobId sa ->
      case b of
        JobId sb -> String.eq sa sb

-- | Find a job entry by ID
findJob : JobId -> List JobEntry -> Maybe JobEntry
findJob targetId entries =
  case entries of
    Nil -> Nothing
    Cons entry rest ->
      case jobIdEq targetId entry.spec.id of
        True -> Just entry
        False -> findJob targetId rest

-- | Check if a JobId is in a list
memberJobId : JobId -> List JobId -> Bool
memberJobId targetId ids =
  case ids of
    Nil -> False
    Cons id rest ->
      case jobIdEq targetId id of
        True -> True
        False -> memberJobId targetId rest

-- | Remove a job entry by ID
removeJob : JobId -> List JobEntry -> List JobEntry
removeJob targetId entries =
  case entries of
    Nil -> Nil
    Cons entry rest ->
      case jobIdEq targetId entry.spec.id of
        True -> rest
        False -> Cons entry (removeJob targetId rest)

-- | Remove a JobId from a list
removeJobId : JobId -> List JobId -> List JobId
removeJobId targetId ids =
  case ids of
    Nil -> Nil
    Cons id rest ->
      case jobIdEq targetId id of
        True -> rest
        False -> Cons id (removeJobId targetId rest)
