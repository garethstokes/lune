module Lune.Api exposing (
  Api,
  run,
  context,
  fail,
  orFail,
  mapError,
  pure,
  andThen,
  -- jsonBody, -- FIXME: Kind error when Pair is imported
  serve,
  ServerConfig,
  Route,
  Routes
)

import Lune.Prelude exposing (IO, Result(..), Maybe(..), Unit, List(..), Int, Bool(..), unit, Pair(..))
import Lune.IO as IO
import Lune.Http exposing (Request, Response, Method(..))
import Lune.Http.Server as Server
import Lune.String as Str
import Lune.Json as Json
import Lune.Json.Decode as D

{-| Api e a represents an API computation that:
    - Has read access to context of type ctx (implicit via run)
    - Can fail with error type e
    - Returns a value of type a
-}
type Api e a = Api#

type alias ServerConfig e ctx =
  { port : Int
  , errorHandler : e -> Response
  , context : ctx
  }

{-| A route combines a method, path pattern, and handler.
    Path patterns use :param syntax for path parameters.
-}
type alias Route e ctx =
  { method : Method
  , pattern : String
  , handler : Request -> ctx -> Api e Response
  }

type alias Routes e ctx = List (Route e ctx)

-- Core Api operations (primitives)
run : ctx -> Api e a -> IO (Result e a)
run = prim_apiRun

context : Api e ctx
context = prim_apiContext

fail : e -> Api e a
fail = prim_apiFail

orFail : e -> Maybe a -> Api e a
orFail err maybe =
  case maybe of
    Nothing -> fail err
    Just a -> pure a

mapError : (e1 -> e2) -> Api e1 a -> Api e2 a
mapError = prim_apiMapError

pure : a -> Api e a
pure = prim_apiPure

andThen : (a -> Api e b) -> Api e a -> Api e b
andThen = prim_apiAndThen

-- FIXME: Commented out due to kind error when Pair is imported
-- {-| Parse the request body as JSON using the given decoder.
--     On decode failure, calls toErr to convert the error message
--     to the application's error type.
-- -}
-- jsonBody : (String -> e) -> D.Decoder a -> Request -> Api e a
-- jsonBody toErr decoder request =
--   case Json.parse request.body of
--     Err msg -> fail (toErr msg)
--     Ok json ->
--       case D.decodeValue decoder json of
--         Err decodeErr -> fail (toErr decodeErr.message)
--         Ok value -> pure value

-- Server
serve : ServerConfig e ctx -> Routes e ctx -> IO Unit
serve config routes =
  Server.serve config.port (handleRequest config routes)

handleRequest : ServerConfig e ctx -> Routes e ctx -> Request -> IO Response
handleRequest config routes request =
  case findMatchingRoute request routes of
    Nothing ->
      IO.pure notFoundResponse
    Just route ->
      do
        result <- run config.context (route.handler request config.context)
        case result of
          Err e -> IO.pure (config.errorHandler e)
          Ok response -> IO.pure response

findMatchingRoute : Request -> Routes e ctx -> Maybe (Route e ctx)
findMatchingRoute request routes =
  case routes of
    [] -> Nothing
    Cons route rest ->
      case methodMatches request.method route.method of
        False -> findMatchingRoute request rest
        True ->
          case prim_matchPath route.pattern request.path of
            Nothing -> findMatchingRoute request rest
            Just _ -> Just route

methodMatches : Method -> Method -> Bool
methodMatches m1 m2 =
  case (m1, m2) of
    (GET, GET) -> True
    (POST, POST) -> True
    (PUT, PUT) -> True
    (PATCH, PATCH) -> True
    (DELETE, DELETE) -> True
    _ -> False

notFoundResponse : Response
notFoundResponse =
  { status = 404
  , headers = [{ key = "Content-Type", value = "application/json" }]
  , body = "{\"error\":\"Not Found\"}"
  }
