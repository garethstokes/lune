module Lune.Http.Request exposing (
  query,
  header,
  queryParams
)

import Lune.Prelude exposing (String, Maybe(..), List(..), Bool(..))
import Lune.Http exposing (Request)
import Lune.String as Str

query : String -> Request -> Maybe String
query key req =
  findParam key (parseQueryString req.path)

header : String -> Request -> Maybe String
header name req =
  findHeader (Str.toLower name) req.headers

queryParams : Request -> List { key : String, value : String }
queryParams req =
  parseQueryString req.path

-- ===== Internal =====

parseQueryString : String -> List { key : String, value : String }
parseQueryString path =
  case Str.indexOf "?" path of
    Nothing -> Nil
    Just idx ->
      case Str.drop (prim_addInt idx 1) path of
        qs ->
          case Str.isEmpty qs of
            True -> Nil
            False -> listMap parsePair (Str.split "&" qs)

parsePair : String -> { key : String, value : String }
parsePair p =
  case Str.indexOf "=" p of
    Nothing -> { key = p, value = "" }
    Just idx ->
      { key = Str.take idx p
      , value = Str.drop (prim_addInt idx 1) p
      }

findParam : String -> List { key : String, value : String } -> Maybe String
findParam key params =
  case params of
    Nil -> Nothing
    Cons p rest ->
      case Str.eq key p.key of
        True -> Just p.value
        False -> findParam key rest

findHeader : String -> List { key : String, value : String } -> Maybe String
findHeader lowerName headers =
  case headers of
    Nil -> Nothing
    Cons h rest ->
      case Str.eq lowerName (Str.toLower h.key) of
        True -> Just h.value
        False -> findHeader lowerName rest

listMap : (a -> b) -> List a -> List b
listMap f xs =
  case xs of
    Nil -> Nil
    Cons x rest -> Cons (f x) (listMap f rest)
