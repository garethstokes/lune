module Lune.Http.Api exposing (
  serve,
  ServerConfig,
  Route,
  Routes,
  jsonBody,
  orFail,
  pure,
  fail
)

import Lune.Prelude exposing (IO, Result(..), Maybe(..), Unit, List(..), Int, Bool(..), String, unit)
import Lune.IO as IO
import Lune.Http exposing (Request, Response, Method(..))
import Lune.Http.Server as Server
import Lune.String as Str
import Lune.Json as Json
import Lune.Json.Decode as D

type alias ServerConfig e ctx =
  { port : Int
  , errorHandler : e -> Response
  , context : ctx
  }

type alias Route e ctx =
  { method : Method
  , pattern : String
  , handler : Request -> ctx -> IO (Result e Response)
  }

type alias Routes e ctx = List (Route e ctx)

pure : a -> IO (Result e a)
pure a = IO.pure (Ok a)

fail : e -> IO (Result e a)
fail e = IO.pure (Err e)

orFail : e -> Maybe a -> IO (Result e a)
orFail err maybe =
  case maybe of
    Nothing -> fail err
    Just a -> pure a

jsonBody : (String -> e) -> D.Decoder a -> Request -> Result e a
jsonBody toErr decoder request =
  case Json.parse request.body of
    Err msg -> Err (toErr msg)
    Ok json ->
      case D.decodeValue decoder json of
        Err decodeErr -> Err (toErr decodeErr.message)
        Ok value -> Ok value

serve : ServerConfig e ctx -> Routes e ctx -> IO Unit
serve config routes =
  Server.serve config.port (handleRequest config routes)

handleRequest : ServerConfig e ctx -> Routes e ctx -> Request -> IO Response
handleRequest config routes request =
  case findMatchingRoute request routes of
    Nothing ->
      IO.pure notFoundResponse
    Just route ->
      do
        result <- route.handler request config.context
        case result of
          Err e -> IO.pure (config.errorHandler e)
          Ok response -> IO.pure response

findMatchingRoute : Request -> Routes e ctx -> Maybe (Route e ctx)
findMatchingRoute request routes =
  case routes of
    Nil -> Nothing
    Cons route rest ->
      case methodMatches request.method route.method of
        False -> findMatchingRoute request rest
        True ->
          case matchPath route.pattern request.path of
            False -> findMatchingRoute request rest
            True -> Just route

methodMatches : Method -> Method -> Bool
methodMatches m1 m2 =
  case m1 of
    GET ->
      case m2 of
        GET -> True
        _ -> False
    POST ->
      case m2 of
        POST -> True
        _ -> False
    PUT ->
      case m2 of
        PUT -> True
        _ -> False
    PATCH ->
      case m2 of
        PATCH -> True
        _ -> False
    DELETE ->
      case m2 of
        DELETE -> True
        _ -> False

matchPath : String -> String -> Bool
matchPath pattern rawPath =
  matchParts (filterEmpty (Str.split "/" pattern)) (filterEmpty (Str.split "/" (stripQueryString rawPath)))

stripQueryString : String -> String
stripQueryString path =
  case Str.indexOf "?" path of
    Nothing -> path
    Just idx -> Str.take idx path

matchParts : List String -> List String -> Bool
matchParts ps vs =
  case ps of
    Nil ->
      case vs of
        Nil -> True
        _ -> False
    Cons p prest ->
      case vs of
        Nil -> False
        Cons v vrest ->
          case Str.startsWith ":" p of
            True -> matchParts prest vrest
            False ->
              case Str.eq p v of
                True -> matchParts prest vrest
                False -> False

filterEmpty : List String -> List String
filterEmpty xs =
  case xs of
    Nil -> Nil
    Cons x rest ->
      case Str.isEmpty x of
        True -> filterEmpty rest
        False -> Cons x (filterEmpty rest)

notFoundResponse : Response
notFoundResponse =
  { status = 404
  , headers = Cons { key = "Content-Type", value = "application/json" } Nil
  , body = "{\"error\":\"Not Found\"}"
  }
